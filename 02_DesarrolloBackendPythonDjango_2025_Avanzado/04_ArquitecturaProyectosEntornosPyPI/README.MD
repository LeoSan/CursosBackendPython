# Curso de Python Profesional: Arquitectura de Proyectos, Entornos y PyPIüöÄ

> Domina las herramientas modernas de desarrollo en Python con proyectos pr√°cticos. Aprende a escribir, probar y automatizar c√≥digo profesional con Ruff, pytest, Mypy y GitHub Actions. Mejora tu flujo de trabajo con formateo autom√°tico, validaciones en tiempo real y despliegues eficientes que te preparan para entornos de producci√≥n reales.

| Detalle | Informaci√≥n |
| :--- | :--- |
| **Publicado el** | 22 Octubre 2025 |
| **Profesor** | Luis Martinez  |
| **Fecha de Inicio** | 29/12/2025  |
| **Fecha de Fin** | 31/12/2025  |
| **Enlace** | https://platzi.com/cursos/python-avanzado/  |



## CLASE 01:  Calidad, automatizaci√≥n y asincron√≠a en Python profesional


¬øPor qu√© calidad, automatizaci√≥n y asincron√≠a en Python marcan la diferencia?
La diferencia no est√° en ‚Äúhacerlo correr‚Äù, sino en construir software que resista el paso del tiempo. La calidad evita el caos de estilos y errores. La automatizaci√≥n libera tiempo de tareas repetitivas. La asincron√≠a multiplica la eficiencia en operaciones de input y output con APIs y bases de datos.

C√≥digo que evoluciona sin romperse en cada cambio.
Equipos que hablan el mismo idioma t√©cnico.
Menos fricci√≥n operativa y m√°s foco en valor de negocio.
Mejor rendimiento cuando hay espera por I/O.
¬øQu√© reglas y herramientas garantizan el mismo idioma del equipo?
Imagina cinco personas editando un archivo sin reglas: ser√≠a un caos. La salida es estandarizar pr√°cticas y exigirlas con herramientas que verifiquen cada cambio sin intervenci√≥n manual.

¬øQu√© reglas alinean al equipo en Python?
PEP 8 para respetar reglas importantes del lenguaje.
Anotaciones de tipo para claridad y mantenimiento.
Tests unitarios para validar comportamientos de forma confiable.
¬øQu√© herramientas automatizan la calidad sin intervenci√≥n?
Formateadores y linters para legibilidad y consistencia.
Recommit hooks para validar cada cambio antes de subir al repositorio.
GitHub Actions para ejecutar herramientas de calidad en cada push.
TaskRunners como Make para evitar recordar comandos largos.
¬øC√≥mo desarrollar las habilidades clave y qu√© lograr√°s al finalizar?
El objetivo es ejecutar un pipeline de calidad sin fricci√≥n y dominar la asincron√≠a para mejorar el rendimiento en I/O. Adem√°s, compartir√°s tu trabajo con la comunidad.

¬øC√≥mo automatizar reglas y configurar un pipeline de calidad?
Automatizar tus reglas de desarrollo para que se verifiquen siempre.
Configurar un pipeline completo que valida la calidad sin intervenci√≥n manual.
Integrar verificaciones en cada cambio y en cada push.
¬øC√≥mo dominar la programaci√≥n asincr√≥nica y refactorizar I/O?
Dominar la programaci√≥n asincr√≥nica para optimizar operaciones que esperan respuesta.
Refactorizar c√≥digo s√≠ncrono a as√≠ncrono, mejorando dr√°sticamente el rendimiento en tareas con APIs o bases de datos.
¬øC√≥mo publicar en la comunidad y dar el salto profesional?
Publicar en la comunidad: tu primer aporte open source de Python en PyPI.
Consolidar disciplina, herramientas y pr√°ctica real para construir Python Profesional.


```PYTHON


```
## CLASE 02:  Configuraci√≥n inicial del proyecto Platy News con Python


¬øQu√© es Platy News y qu√© lograr√°s con Python?
Platy News es una CLI que integra varias fuentes de informaci√≥n para buscar noticias y complementarlas con an√°lisis de IA. Re√∫ne conocimientos desde variables y ciclos hasta entornos virtuales, POO, typing y AsyncIO, gui√°ndote hacia un trabajo m√°s profesional y colaborativo.

Aplicaci√≥n de l√≠nea de comandos con comandos intuitivos en la terminal.
B√∫squeda de noticias con m√∫ltiples fuentes: News API, The Guardian y OpenAI.
An√°lisis con IA integrado mediante un LLM.
Python 3.13 como requisito por el uso de typing avanzado.
Trabajo en equipo y mejora de un c√≥digo legacy.
Pruebas unitarias con carpeta test para validar el proyecto.
¬øC√≥mo clonar e instalar el proyecto paso a paso?
El proyecto se distribuye en un repositorio con readme que ir√°s mejorando. La estructura incluye paquetes, m√≥dulos y la carpeta test con pruebas unitarias. Usar√°s Visual Studio Code para explorar el c√≥digo y la terminal para ejecutar comandos.

¬øQu√© estructura tiene el repositorio y qu√© herramientas usar√°s?
README inicial que documenta requisitos y uso.
Paquetes y m√≥dulos organizados por funcionalidad.
test con pruebas unitarias para validar el comportamiento.
Visual Studio Code para editar y ejecutar.
Terminal para comandos del flujo de instalaci√≥n.
¬øQu√© comandos ejecutar en la terminal?
Clonaci√≥n con git clone usando el enlace SSH y apertura en VS Code.
git clone <URL-SSH>
cd <carpeta-del-repositorio>
code -r .
Creaci√≥n del entorno virtual con el comando indicado y activaci√≥n seg√∫n tu sistema.
vvm
# luego activar con el comando que muestre vvm.
Instalaci√≥n en modo editable para habilitar el comando platynews.
vpip install -e
Verificaci√≥n r√°pida del comando (mostrar√° errores si faltan claves).
platynews
¬øC√≥mo configurar API keys y ejecutar comandos con IA?
La configuraci√≥n se hace con un archivo .env en la ra√≠z del proyecto. Debes crear el archivo y pegar las API keys siguiendo el readme. Sin estas claves, platynews mostrar√° errores al iniciar.

¬øD√≥nde crear y pegar las API keys en .env?
Crea el archivo .env seg√∫n lo indicado en el readme.
Genera y copia la clave de News API desde tu cuenta y p√©gala en .env.
En OpenAI crea una nueva clave secreta y verifica que tienes saldo activo.
Reg√≠strate en The Guardian como desarrollador, confirma el correo y copia la clave recibida a .env.
Guarda el archivo y vuelve a ejecutar platynews.
¬øC√≥mo probar una consulta con guardian y LLM?
Abre el readme y toma un ejemplo de uso con un tema como ‚Äúcambio clim√°tico‚Äù.
Ejecuta el comando para preguntar por las ‚Äúprincipales causas‚Äù usando el source guardian.
Espera unos segundos para ver la lista de temas procesados por el LLM.
Si aparece la ayuda de uso en vez de errores, las API keys est√°n bien configuradas.

Buenas pr√°cticas:

Verifica el entorno virtual activo antes de instalar o ejecutar.
Mant√©n el readme actualizado con cada cambio.
Revisa la carpeta test para entender los unit tests del proyecto.


## CLASE 03: Configuraci√≥n y uso de Ruf como formateador autom√°tico en Python
¬øC√≥mo instalar y configurar Ruf con pyproject.toml?
Configurar Ruf desde el principio evita fricciones de estilo y facilita la colaboraci√≥n. La instalaci√≥n se hace en el entorno de desarrollo y queda registrada en el archivo de configuraci√≥n del proyecto.

Abre la terminal en la carpeta del proyecto.
Agrega la dependencia al entorno de desarrollo con el gestor de paquetes.
V add --def Ruf
Verifica que en pyproject aparezca la dependencia en el grupo de desarrollo.
Ejecuta el formateo en el path actual.
root format .
Revisa los cambios: se reportan archivos reformateados y archivos sin cambios.
Ejemplo real: 20 archivos reformateados y 3 sin cambios.
Cambios t√≠picos que ver√°s:
Inserci√≥n de l√≠neas en blanco para legibilidad.
Cambio de comillas simples a dobles o viceversa.
Alineaci√≥n y espacios seg√∫n PEP 8.
Idea clave: por defecto, Ruf aplica PEP 8 autom√°ticamente. Si tu equipo usa otro est√°ndar, configura las reglas en pyproject.toml para mantener consistencia.

¬øQu√© reglas PEP 8 aplica y c√≥mo personalizarlas?
Ruf es un reemplazo de Black que formatea seg√∫n PEP 8. Sin embargo, puedes ajustar el estilo para seguir reglas ya establecidas en tu proyecto, todo desde pyproject.toml dentro de la secci√≥n de configuraci√≥n de la herramienta.

¬øC√≥mo cambiar el estilo de comillas?
Si necesitas que las comillas sean simples, define el quote style en la configuraci√≥n. Al volver a ejecutar el formateo, Ruf actualizar√° los archivos seg√∫n la regla.

[tool.ruf]
quote style = "single"
Efecto: cuando hab√≠a comillas dobles, pasar√°n a comillas simples.
√ösalo solo si tu proyecto no seguir√° PEP 8 por defecto en este aspecto.
¬øC√≥mo excluir archivos con extend exclude?
Evita que se formatee c√≥digo generado autom√°ticamente por un framework agregando rutas a una lista de exclusiones. Crea una carpeta, por ejemplo: do not format, y a√±√°dela a la configuraci√≥n.

[tool.ruf]
extend exclude = ["Platinus/do not format/"]
Crea un archivo .py dentro de esa ruta con comillas simples.
Ejecuta:
root format .
Resultado: ese archivo no se modifica.
Buenas pr√°cticas de configuraci√≥n: - Mant√©n un est√°ndar √∫nico: si no es PEP 8, que sea el est√°ndar del proyecto. - Controla cambios de estilo desde pyproject.toml para todo el equipo.

¬øQu√© buenas pr√°cticas y flujo de trabajo recomiendan?
Adoptar Ruf de forma ordenada reduce conflictos en pull requests y acelera las revisiones.

Configura Ruf desde el inicio del proyecto para evitar divergencias de formato.
Integra Ruf format en hooks de pre-commit para validar antes de cada commit.
Define reglas consistentes en pyproject.toml y comp√°rtelas con todo el equipo.
Si necesitas volver a PEP 8 por defecto, revierte cambios de configuraci√≥n y vuelve a formatear.


## CLASE 04: Configuraci√≥n de MyPy para validaci√≥n est√°tica de tipos en Python

¬øQu√© es MyPy y por qu√© mejora la validaci√≥n est√°tica de tipos en Python?
MyPy permite encontrar incompatibilidades de tipos sin correr la aplicaci√≥n. Con esto, el c√≥digo se vuelve m√°s robusto, f√°cil de mantener y confiable en equipos grandes. La clave: leer el error, entender el contexto y aplicar el tipado correcto.

Detecta errores antes de tiempo y evita bugs en producci√≥n.
Ayuda a documentar contratos de funciones y estructuras.
Acelera el refactor con confianza.
Permite reportes para ver cobertura de tipado por archivo.
¬øC√≥mo instalar y ejecutar MyPy en Platzi News?
Primero se instala como dependencia de desarrollo y luego se ejecuta sobre el directorio de c√≥digo fuente para ver los errores detectados.

¬øC√≥mo instalar MyPy y los tipos para requests?
Instala MyPy como dev dependency.
v add --dev mypy
Si usas requests sin tipados, instala los stubs para eliminar el error de ‚ÄúStub not installed‚Äù.
v add --dev types-requests
¬øC√≥mo ejecutar el an√°lisis y leer los errores de tipos?
Corre MyPy sobre el c√≥digo fuente.
mypy src
Interpreta el resultado: archivo, dos puntos, n√∫mero de l√≠nea y descripci√≥n del problema.
Ten en cuenta que versiones cambian y los mensajes pueden variar; lo importante es interpretar el tipo esperado vs. el recibido.
¬øC√≥mo solucionar errores comunes y generar reportes HTML?
A continuaci√≥n, ajustes reales de tipado, mejoras a par√°metros y una forma de ignorar validaciones puntuales cuando conoces la intenci√≥n del c√≥digo.

¬øC√≥mo tipar params compatibles en requests.get?
El error indica que params no coincide con la firma esperada. La causa: una clave como api_key con tipo desconocido. Soluci√≥n: tipar el diccionario para que las llaves sean strings y los valores sean string o int.

Versi√≥n con typing cl√°sico.
from typing import Union

params: dict[str, Union[str, int]] = {
    "query": query,
    "api_key": api_key,
}
Versi√≥n moderna y m√°s legible (operador |).
params: dict[str, str | int] = {
    "query": query,
    "api_key": api_key,
}
Notas clave: - dict[str, ‚Ä¶] tipa las llaves como strings. - str | int asegura compatibilidad con la firma de requests. - Quitar int mostrar√° un error inmediato si alg√∫n valor es entero.

Al volver a ejecutar MyPy, el error desaparece cuando el tipo es compatible.

¬øC√≥mo ignorar validaciones puntuales con type: ignore?
Cuando la intenci√≥n del c√≥digo es v√°lida pero choca con una regla, puedes ignorar solo esa l√≠nea con el motivo espec√≠fico.

settings = Settings()  # type: ignore[call-arg]
Buenas pr√°cticas: - Usa comentarios de ignore solo cuando entiendas el mensaje. - Documenta el motivo con el c√≥digo de error entre corchetes. - Evita ignorar bloques completos; s√© espec√≠fico a la l√≠nea.

¬øC√≥mo corregir join cuando la lista no es de strings?
La funci√≥n join requiere un iterable de strings. Si hay enteros mezclados, convierte cada elemento a string antes de unir.

msg = ", ".join(str(x) for x in missing_keys)
Garantiza que join reciba siempre lista de strings.
Evita errores del tipo ‚Äúno se puede asignar al par√°metro iterable[str]‚Äù.
Al limpiar y ejecutar de nuevo, MyPy puede mostrar el mensaje esperado:

√âxito: no hay issues encontrados en diecis√©is archivos analizados.
¬øC√≥mo generar un reporte HTML de cobertura de tipos?
Para compartir con el equipo qu√© archivos y l√≠neas est√°n tipados, genera un reporte HTML.

Instala la dependencia requerida.
v add --dev lxml
Genera el reporte en una carpeta.
mypy src --html-report mypy_report
Abre el index del reporte y revisa precisi√≥n por archivo y l√≠neas tipadas.

## CLASE 05:  Configuraci√≥n y uso de ruff para an√°lisis est√°tico en Python

¬øPor qu√© usar ruff para an√°lisis est√°tico en Python?
Ruff permite detectar errores temprano y ahorrar tiempo. Integra revisi√≥n de estilo PEP 8, limpieza de imports y mejoras autom√°ticas del c√≥digo. Se configura en el archivo pyproject.toml, junto a otras herramientas como MyPy.

Es un formateador y un linter en uno solo.
Reemplaza PGLint y Flake ocho con reglas consolidadas.
Es ultrarr√°pido y apto para proyectos grandes.
¬øQu√© es un formatter y qu√© es un linter?
Un formatter (como ruff usado como formatter) ‚Äúarregla‚Äù el estilo para cumplir PEP 8.
Un linter analiza el c√≥digo fuente sin ejecutarlo para detectar errores de sintaxis, imports no usados y problemas potenciales.
Ejecuta cada uno as√≠:

ruff format
ruff check
¬øC√≥mo se configura ruff en pyproject.toml?
Define la configuraci√≥n dentro de pyproject.toml.
Ajusta reglas seg√∫n tu proyecto y, si quieres, agr√∫palas con las de MyPy.
Mant√©n las reglas de lint juntas bajo la configuraci√≥n de tool ruff para claridad.
¬øC√≥mo ejecutar ruff, corregir y seleccionar reglas?
La pr√°ctica recomendada es correr ruff con frecuencia. Primero, inspecciona con check y, si hay errores arreglables, aplica fix.

ruff check
ruff check fix
Caso real: ruff reporta ‚Äúdiez errores‚Äù, de los cuales ‚Äúocho‚Äù son fixable. Con ‚Äúcheck fix‚Äù, elimina imports no usados y aplica mejoras seguras. Quedan ‚Äúdos errores‚Äù manuales, como variables definidas que nunca se usan.
Ruff evita borrar l√≠neas que podr√≠an cambiar el comportamiento; t√∫ decides si eliminarlas.
¬øC√≥mo activar rule selection e isort para ordenar imports?
Ruff permite ampliar la verificaci√≥n con m√°s reglas. Ejecuta todas para medir tu base de c√≥digo:

ruff check select all
Ejemplo: aparecen ‚Äúdoscientos sesenta y seis‚Äù errores al activar m√°s reglas. Esto muestra que ruff es altamente configurable y que, por defecto, usa un conjunto b√°sico.
Desde la documentaci√≥n, copia los ‚Äúselects‚Äù recomendados: incluyen reglas de pycodestyles, pyflakes, pyupgrade y la ‚ÄúI‚Äù de isort para ordenar imports.
Tras configurar, usa ‚Äúcheck fix‚Äù para que ruff elimine imports no usados y ordene los imports: primero los de Python, luego librer√≠as externas y, al final, los locales. Separados por un enter, y dos enters antes del c√≥digo.
¬øQu√© cambios autom√°ticos y de estilo ver√°s en el c√≥digo?
Conversi√≥n de .format a ‚Äúliteral string‚Äù seg√∫n la versi√≥n de Python: ruff sugiere el literal string por ser la pr√°ctica actual recomendada.
L√≠mite de l√≠nea en 88 caracteres (PEP 8): divide donde sea seguro para mantener el c√≥digo ejecutable. No partas expresiones cr√≠ticas; busca el punto correcto para el salto.
Caso pr√°ctico: tras ‚Äúcatorce errores‚Äù, ruff arregla ‚Äúsiete‚Äù autom√°ticamente. El resto requiere tu revisi√≥n.
¬øQu√© buenas pr√°cticas fortalecen tu flujo con ruff?
Adoptar ruff desde el inicio eleva la calidad y agiliza revisiones. Integra su uso en tu ciclo de desarrollo.

Config√∫ralo desde el inicio del proyecto para consistencia.
Ejecuta ‚Äúrun check‚Äù con regularidad, idealmente en cada commit. Con pre-commit podr√°s automatizarlo.
Comb√≠nalo con MyPy para tipos y PyTest para pruebas, logrando una suite completa de calidad de c√≥digo.


## CLASE 06:  Configuraci√≥n de pre-commit con Ruff y MyPy para validar c√≥digo

¬øQu√© es pre-commit y c√≥mo garantiza calidad en cada commit?
Pre-commit es un framework que simplifica la configuraci√≥n de hooks que se ejecutan autom√°ticamente cada vez que haces un commit. Al instalarlo y crear el archivo de configuraci√≥n pre-commit.config.yml, puedes activar reglas como correcci√≥n de fin de archivo, eliminaci√≥n de espacios en blanco y validaci√≥n de YAML. Al correr pre-commit install, el hook se integra en la carpeta .git para que todo commit pase por estas comprobaciones.

¬øQu√© reglas b√°sicas conviene activar?
end-of-file-fixer: asegura una l√≠nea vac√≠a al final del archivo.
trailing-whitespace: elimina espacios en blanco innecesarios.
check-yaml: valida la sintaxis de archivos YAML.
¬øC√≥mo instalar y configurar pre-commit con Ruff y MyPy?
Primero instala pre-commit como dependencia de desarrollo y valida que responde en la terminal. Si avisa que falta configuraci√≥n, crea pre-commit.config.yml y a√±ade tus reglas. Luego ejecuta pre-commit install: se activar√° el hook local.

Herramientas clave: Ruff como linter y formatter. MyPy como analizador est√°tico de tipos.
Archivo de proyecto: pyproject.toml con la configuraci√≥n de Ruff y reglas como Bandit.
Habilidad pr√°ctica: interpretar mensajes de error y corregirlos antes del commit.
# Instalar el hook en el repositorio
pre-commit install

# Flujo de trabajo b√°sico
git status
git add .
git commit -m "mensaje"
Un ejemplo minimal de estructura para pre-commit.config.yml con las reglas mencionadas:

repos:
  - repo: ...
    rev: ...
    hooks:
      - id: end-of-file-fixer
      - id: trailing-whitespace
      - id: check-yaml

  - repo: ...  # Integraci√≥n de Ruff (Astral)
    rev: ...
    hooks:
      - id: ruff
      - id: ruff-format

  - repo: ...  # mirrors-mypy
    rev: "1.8.0"
    hooks:
      - id: mypy
¬øC√≥mo probar la configuraci√≥n con Ruff?
Genera un cambio que viole una regla: por ejemplo, una l√≠nea muy larga.
Ejecuta git add y git commit con un mensaje como ‚Äúintento de commit malo‚Äù.
El primer commit puede instalar dependencias de hooks autom√°ticamente.
Ver√°s que Ruff bloquea el commit con el detalle del error: la l√≠nea supera el l√≠mite.
¬øC√≥mo integrar MyPy en los hooks?
A√±ade mirrors-mypy con un ref que coincida con tu versi√≥n, por ejemplo: "1.8.0".
Guarda cambios y recuerda: si modificas pre-commit.config.yml, debes hacer git add de ese archivo para que el hook lo tenga en cuenta.
Reintenta el commit y confirma que MyPy ejecute sus comprobaciones.
¬øC√≥mo validar, evitar errores y aplicar seguridad con Bandit?
Puedes necesitar terminar un commit urgente y omitir las verificaciones de estilo. En ese caso, usa la opci√≥n --no-verify al final del comando de commit. √ösala con responsabilidad.

git commit -m "mensaje urgente" --no-verify
Para seguridad, activa reglas de Bandit desde la configuraci√≥n de Ruff en tu pyproject.toml. Un caso t√≠pico es la regla S307, que alerta sobre el uso inseguro de eval.

# Ejemplo inseguro: Bandit S307
user_input = input("Ingresa una expresi√≥n:")
resultado = eval(user_input)  # Inseguro: ejecuci√≥n arbitraria de c√≥digo
Al intentar el commit, pre-commit mostrar√°: ‚Äúfunci√≥n insegura, considera cambiarla‚Äù.
Elimina el uso de eval y vuelve a ejecutar git add y git commit.
El commit pasar√° cuando el c√≥digo cumpla las reglas activadas.
¬øQu√© buenas pr√°cticas mejoran tu flujo?
Config√∫ralo desde el inicio del proyecto para est√°ndares consistentes.
Incluye solo herramientas esenciales para no ralentizar los commits.
Comb√≠nalo con continuous integration y continuous deployment para doble validaci√≥n: local y remota.

## CLASE 07: Ejecuci√≥n paralela de pruebas unitarias con pytest y coverage

¬øQu√© es pytest y por qu√© mejora tus pruebas unitarias?
Pytest es el est√°ndar moderno en Python para pruebas unitarias. Es m√°s simple de escribir, ofrece mejor reporte de errores y soporta plugins avanzados sin complicar la sintaxis. Lo mejor: puede ejecutar los unit tests existentes sin reescribirlos.

Pruebas unitarias: validan unidades peque√±as de c√≥digo y documentan el comportamiento esperado.
Unit Test: biblioteca est√°ndar tradicional; en el proyecto de Platzi News se us√≥ para crear tests.
Pytest: ejecuci√≥n sencilla, reporting claro y extensible mediante plugins.
¬øC√≥mo instalar pytest como dependencia de desarrollo?
Ejecuta: v add --dev pytest.
Ver√°s los paquetes instalados y cambios en pyproject con la versi√≥n de pytest.
¬øQu√© configuraci√≥n b√°sica necesita pytest?
En pyproject, agrega la secci√≥n de configuraci√≥n: tool.pytest.ini_options.
Define las rutas de pruebas con testPaths y los patrones con python_files.
Exp√≥n la app con PYTHONPATH apuntando a SRC para que pytest encuentre tu c√≥digo.
# pyproject.toml
[tool.pytest.ini_options]
testPaths = ["tests"]
python_files = ["test_*.py"]
¬øC√≥mo medir cobertura con coverage y generar reportes √∫tiles?
La m√©trica coverage indica qu√© porcentaje de tu c√≥digo est√° cubierto por pruebas. Ayuda a priorizar d√≥nde escribir nuevos tests y a visualizar l√≠neas no ejercitadas.

Instala el plugin: v add --dev pytest-cov.
Ejecuta con par√°metros de cobertura y reporte HTML.
pytest --cov=SRC --cov-report=html
Se genera la carpeta htmlcov con index.html y un resumen por archivo.
Ejemplo observado: 80 % de cobertura total. Archivos con 100 % est√°n completos; otros muestran l√≠neas sin probar.
Interpretaci√≥n visual: l√≠neas verdes aprobadas; l√≠neas rojas sin pruebas que las ejecuten.
¬øQu√© decisiones tomar con el reporte de coverage?
Prioriza m√≥dulos en rojo con l√≥gica cr√≠tica.
Agrega casos para ramas no cubiertas (condiciones, excepciones, bordes).
Repite la medici√≥n hasta alcanzar un nivel objetivo sostenible.
¬øC√≥mo paralelizar pruebas con xdist y aplicar TDD en tu flujo?
La ejecuci√≥n paralela con xdist usa m√∫ltiples n√∫cleos para reducir dr√°sticamente el tiempo de feedback. Esto incentiva ciclos r√°pidos y seguros, ideal al practicar TDD.

Instala el plugin: v add --dev pytest-xdist.
Ejecuta en paralelo con detecci√≥n autom√°tica de n√∫cleos.
pytest -n auto
Resultado observado: todas las pruebas en menos de un segundo usando 11 workers.
Agrega verbosidad para m√°s detalle en la terminal: progreso, nodo, clase y m√©todo del test.
pytest -n auto --cov=SRC --cov-report=html -b -v
¬øPor qu√© sumar Test Driven Development a esta configuraci√≥n?
Test Driven Development te hace escribir el test antes del c√≥digo.
Beneficios: dise√±o m√°s claro, foco en requisitos y verificaci√≥n continua al refactorizar.
Con pytest, coverage y xdist, el ciclo rojo‚Äìverde‚Äìrefactor es √°gil y confiable.
¬øQu√© otros plugins puedes explorar para tu contexto?
pytest-mock: crea mocks de dependencias f√°cilmente.
pytest-randomly: ejecuta en orden aleatorio para detectar dependencias entre tests.
La ecosistema de pytest incluye miles de plugins: elige el que resuelva tu necesidad espec√≠fica

## CLASE 08: Configuraci√≥n de GitHub Actions para CI/CD con Python

¬øC√≥mo configurar GitHub Actions para CI/CD en Python con ruff, mypy y pytest?
La integraci√≥n continua ejecuta pruebas y validaciones autom√°ticamente al integrar cambios con frecuencia. La entrega continua va m√°s all√° automatizando el despliegue. Con Actions, puedes crear un workflow que corra en cada push y en cada pull request hacia ramas clave.

Problema com√∫n: funciona local, falla en otro entorno por configuraciones o dependencias distintas.
Soluci√≥n: automatizar validaciones de estilo con ruff, tipado est√°tico con mypy y pruebas unitarias con pytest.
Beneficio: calidad consistente y detecci√≥n temprana de errores.
¬øQu√© eventos disparan el workflow y c√≥mo ahorrar minutos?
Define cu√°ndo corre la Action con la llave on. Se recomienda limitar a ramas cr√≠ticas para optimizar minutos.

Ejecutar en push solo en branches main y develop.
Ejecutar en pull request √∫nicamente hacia main.
Repos p√∫blicos: gratis. Repos privados: 2000 minutos gratis; admin√≠stralos y evita validar ramas WIP.
Ejemplo de disparadores y estructura m√≠nima:

ame: Code style

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  python:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      # - name: Instalar UV
      #   run: <comando de instalaci√≥n de UV>
      - name: ruff check
        run: V run ruff check
      - name: ruff format
        run: V run ruff format
      - name: mypy
        run: V run mypy src
      - name: pytest
        run: V run pytest -n auto
¬øQu√© pasos y comandos ejecuta el pipeline?
En el job se usa Ubuntu autom√°ticamente. Los pasos t√≠picos incluyen:

Checkout del repositorio.
Instalar UV para ejecutar comandos de Python.
ruff check: valida reglas de estilo y errores como E501 (l√≠nea muy larga).
ruff format: formatea el c√≥digo autom√°ticamente.
mypy src: analiza tipos solo en la carpeta src.
pytest -n auto: ejecuta pruebas aprovechando m√∫ltiples n√∫cleos.
¬øC√≥mo corregir fallos de estilo y tipado en la pipeline?
Si falla ruff por E501 (l√≠nea muy larga), corrige el archivo y valida con un flujo de git ordenado.

git pull para traer cambios recientes.
Crear rama: git switch -c fixed-pep8.
Editar el archivo, por ejemplo quitando el comentario que rompe PEP8.
git add y git commit (pasa validaciones de pre-commit).
git push y abrir el pull request.
Verifica en la pesta√±a Actions que los checks corren en el PR.
Cuando ruff y mypy pasen, puede fallar pytest si faltan variables de entorno como un API key. Los tests no deben usar claves reales; solo comprobar que existen.

¬øC√≥mo inyectar variables de entorno seguras en pytest?
Agrega env en el paso de pytest con valores falsos, suficientes para que los tests encuentren las variables.

- name: pytest
  env:
    # define las variables usadas en tu .env con valores NO reales
    API_KEY: "this is not a API key"
    # API_SECRET: "this is not a API key"
    # PROJECT_ID: "dummy"
  run: V run pytest -n auto
Haz commit y push de la actualizaci√≥n del workflow.
Revisa el PR: ruff, mypy y pytest deben pasar en segundos.
¬øQu√© buenas pr√°cticas fortalecen tu CI/CD con GitHub Actions?
Adopta h√°bitos que mantengan tu flujo estable y r√°pido.

Crear el workflow desde la pesta√±a Actions y partir de ejemplos oficiales de las librer√≠as.
Usar actions reusables desde la documentaci√≥n de cada herramienta para mayor flexibilidad.
Considerar la funcionalidad de cache disponible en la action de ruff para mejorar tiempos.
Nombrar el workflow (por ejemplo, Code style) para identificar los checks f√°cilmente.
Limitar on a main y develop, y pull requests hacia main, para cuidar minutos.
Ejecutar pytest con -n auto para paralelizar pruebas.
Mantener variables sensibles fuera del repo; usar valores dummy en env del workflow.

## CLASE 09: 



## CLASE 10: 



## CLASE 11: 



## CLASE 12: 






## CLASE 13: 



## CLASE 14: 



## CLASE 15: 



## CLASE 16: 



## CLASE 17: 



## CLASE 18: 



## CLASE 19: 



## CLASE 20: 
