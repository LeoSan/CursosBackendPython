# Curso de Python Profesional: Arquitectura de Proyectos, Entornos y PyPIüöÄ

> Domina las herramientas modernas de desarrollo en Python con proyectos pr√°cticos. Aprende a escribir, probar y automatizar c√≥digo profesional con Ruff, pytest, Mypy y GitHub Actions. Mejora tu flujo de trabajo con formateo autom√°tico, validaciones en tiempo real y despliegues eficientes que te preparan para entornos de producci√≥n reales.

| Detalle | Informaci√≥n |
| :--- | :--- |
| **Publicado el** | 22 Octubre 2025 |
| **Profesor** | Luis Martinez  |
| **Fecha de Inicio** | 29/11/2025  |
| **Fecha de Fin** | 31/12/2025  |
| **Enlace** | https://platzi.com/cursos/python-avanzado/  |


---
<div align="center">
  <img src="image-2.png" alt="Global Certificate" width="50%" />
</div>


| Curso | Certificado |
| :--- | :---: |
| Diploma Curso de Python Profesional: Arquitectura de Proyectos, Entornos y PyPI | [Ver PDF](https://github.com/LeoSan/CursosBackendPython/blob/main/02_DesarrolloBackendPythonDjango_2025_Avanzado\04_ArquitecturaProyectosEntornosPyPI\2025_CursoPythonProfesionalArquitecturaPIP_PLATZI.pdf) |

--- 



## Tabla de Contenidos
- [CLASE 01:  Calidad, automatizaci√≥n y asincron√≠a en Python profesional](#clase-01--calidad,-automatizacion-y-asincronia-en-python-profesional)
- [CLASE 02:  Configuraci√≥n inicial del proyecto Platy News con Python](#clase-02--configuracion-inicial-del-proyecto-platy-news-con-python)
- [CLASE 03: Configuraci√≥n y uso de Ruf como formateador autom√°tico en Python](#clase-03-configuracion-y-uso-de-ruf-como-formateador-automatico-en-python)
- [CLASE 04: Configuraci√≥n de MyPy para validaci√≥n est√°tica de tipos en Python](#clase-04-configuracion-de-mypy-para-validacion-estatica-de-tipos-en-python)
- [CLASE 05:  Configuraci√≥n y uso de ruff para an√°lisis est√°tico en Python](#clase-05--configuracion-y-uso-de-ruff-para-analisis-estatico-en-python)
- [CLASE 06:  Configuraci√≥n de pre-commit con Ruff y MyPy para validar c√≥digo](#clase-06--configuracion-de-pre-commit-con-ruff-y-mypy-para-validar-codigo)
- [CLASE 07: Ejecuci√≥n paralela de pruebas unitarias con pytest y coverage](#clase-07-ejecucion-paralela-de-pruebas-unitarias-con-pytest-y-coverage)
- [CLASE 08: Configuraci√≥n de GitHub Actions para CI/CD con Python](#clase-08-configuracion-de-github-actions-para-ci/cd-con-python)
- [CLASE 09: Configuraci√≥n de logging y Sentry para monitoreo en producci√≥n](#clase-09-configuracion-de-logging-y-sentry-para-monitoreo-en-produccion)
- [CLASE 10: Medici√≥n de rendimiento de c√≥digo con Timeit en Python](#clase-10-medicion-de-rendimiento-de-codigo-con-timeit-en-python)
- [CLASE 11: An√°lisis de rendimiento en Python con cProfile y Snakeviz](#clase-11-analisis-de-rendimiento-en-python-con-cprofile-y-snakeviz)
- [CLASE 12: Programaci√≥n as√≠ncrona en Python con AsyncIO para operaciones I/O](#clase-12-programacion-asincrona-en-python-con-asyncio-para-operaciones-i/o)
- [CLASE 13: Sintaxis async y await en Python para concurrencia eficiente](#clase-13-sintaxis-async-y-await-en-python-para-concurrencia-eficiente)
- [CLASE 14: Event loop de asyncio: creaci√≥n manual y debugging avanzado](#clase-14-event-loop-de-asyncio-creacion-manual-y-debugging-avanzado)
- [CLASE 15: Migraci√≥n de Request s√≠ncrono a HTTPX as√≠ncrono en Python](#clase-15-migracion-de-request-sincrono-a-httpx-asincrono-en-python)
- [CLASE 16: Automatizaci√≥n de tareas con Make y Makefile en proyectos](#clase-16-automatizacion-de-tareas-con-make-y-makefile-en-proyectos)
- [CLASE 17: Publicaci√≥n de paquetes Python con UV y TestPyPI](#clase-17-publicacion-de-paquetes-python-con-uv-y-testpypi)


## CLASE 01:  Calidad, automatizaci√≥n y asincron√≠a en Python profesional

**¬øPor qu√© calidad, automatizaci√≥n y asincron√≠a en Python marcan la diferencia?**
La diferencia no est√° en ‚Äúhacerlo correr‚Äù, sino en construir software que resista el paso del tiempo. La calidad evita el caos de estilos y errores. La automatizaci√≥n libera tiempo de tareas repetitivas. La asincron√≠a multiplica la eficiencia en operaciones de input y output con APIs y bases de datos.

C√≥digo que evoluciona sin romperse en cada cambio.
Equipos que hablan el mismo idioma t√©cnico.
Menos fricci√≥n operativa y m√°s foco en valor de negocio.
Mejor rendimiento cuando hay espera por I/O.

**¬øQu√© reglas y herramientas garantizan el mismo idioma del equipo?**
Imagina cinco personas editando un archivo sin reglas: ser√≠a un caos. La salida es estandarizar pr√°cticas y exigirlas con herramientas que verifiquen cada cambio sin intervenci√≥n manual.


**¬øQu√© reglas alinean al equipo en Python?**
PEP 8 para respetar reglas importantes del lenguaje.
Anotaciones de tipo para claridad y mantenimiento.
Tests unitarios para validar comportamientos de forma confiable.

**¬øQu√© herramientas automatizan la calidad sin intervenci√≥n?**
Formateadores y linters para legibilidad y consistencia.
Recommit hooks para validar cada cambio antes de subir al repositorio.
GitHub Actions para ejecutar herramientas de calidad en cada push.
TaskRunners como Make para evitar recordar comandos largos.

**¬øC√≥mo desarrollar las habilidades clave y qu√© lograr√°s al finalizar?**
El objetivo es ejecutar un pipeline de calidad sin fricci√≥n y dominar la asincron√≠a para mejorar el rendimiento en I/O. Adem√°s, compartir√°s tu trabajo con la comunidad.


**¬øC√≥mo automatizar reglas y configurar un pipeline de calidad?**
Automatizar tus reglas de desarrollo para que se verifiquen siempre.
Configurar un pipeline completo que valida la calidad sin intervenci√≥n manual.
Integrar verificaciones en cada cambio y en cada push.

**¬øC√≥mo dominar la programaci√≥n asincr√≥nica y refactorizar I/O?**
Dominar la programaci√≥n asincr√≥nica para optimizar operaciones que esperan respuesta.
Refactorizar c√≥digo s√≠ncrono a as√≠ncrono, mejorando dr√°sticamente el rendimiento en tareas con APIs o bases de datos.

**¬øC√≥mo publicar en la comunidad y dar el salto profesional?**
Publicar en la comunidad: tu primer aporte open source de Python en PyPI.
Consolidar disciplina, herramientas y pr√°ctica real para construir Python Profesional.


```PYTHON


```

## CLASE 02:  Configuraci√≥n inicial del proyecto Platy News con Python



**¬øQu√© es Platy News y qu√© lograr√°s con Python?**
Platy News es una CLI que integra varias fuentes de informaci√≥n para buscar noticias y complementarlas con an√°lisis de IA. Re√∫ne conocimientos desde variables y ciclos hasta entornos virtuales, POO, typing y AsyncIO, gui√°ndote hacia un trabajo m√°s profesional y colaborativo.

Aplicaci√≥n de l√≠nea de comandos con comandos intuitivos en la terminal.
B√∫squeda de noticias con m√∫ltiples fuentes: News API, The Guardian y OpenAI.
An√°lisis con IA integrado mediante un LLM.
Python 3.13 como requisito por el uso de typing avanzado.
Trabajo en equipo y mejora de un c√≥digo legacy.
Pruebas unitarias con carpeta test para validar el proyecto.

**¬øC√≥mo clonar e instalar el proyecto paso a paso?**
El proyecto se distribuye en un repositorio con readme que ir√°s mejorando. La estructura incluye paquetes, m√≥dulos y la carpeta test con pruebas unitarias. Usar√°s Visual Studio Code para explorar el c√≥digo y la terminal para ejecutar comandos.


**¬øQu√© estructura tiene el repositorio y qu√© herramientas usar√°s?**
README inicial que documenta requisitos y uso.
Paquetes y m√≥dulos organizados por funcionalidad.
test con pruebas unitarias para validar el comportamiento.
Visual Studio Code para editar y ejecutar.
Terminal para comandos del flujo de instalaci√≥n.

**¬øQu√© comandos ejecutar en la terminal?**
Clonaci√≥n con git clone usando el enlace SSH y apertura en VS Code.
git clone <URL-SSH>
cd <carpeta-del-repositorio>
code -r .
Creaci√≥n del entorno virtual con el comando indicado y activaci√≥n seg√∫n tu sistema.
vvm
# luego activar con el comando que muestre vvm.
Instalaci√≥n en modo editable para habilitar el comando platynews.
vpip install -e
Verificaci√≥n r√°pida del comando (mostrar√° errores si faltan claves).
platynews

**¬øC√≥mo configurar API keys y ejecutar comandos con IA?**
La configuraci√≥n se hace con un archivo .env en la ra√≠z del proyecto. Debes crear el archivo y pegar las API keys siguiendo el readme. Sin estas claves, platynews mostrar√° errores al iniciar.


**¬øD√≥nde crear y pegar las API keys en .env?**
Crea el archivo .env seg√∫n lo indicado en el readme.
Genera y copia la clave de News API desde tu cuenta y p√©gala en .env.
En OpenAI crea una nueva clave secreta y verifica que tienes saldo activo.
Reg√≠strate en The Guardian como desarrollador, confirma el correo y copia la clave recibida a .env.
Guarda el archivo y vuelve a ejecutar platynews.

**¬øC√≥mo probar una consulta con guardian y LLM?**
Abre el readme y toma un ejemplo de uso con un tema como ‚Äúcambio clim√°tico‚Äù.
Ejecuta el comando para preguntar por las ‚Äúprincipales causas‚Äù usando el source guardian.
Espera unos segundos para ver la lista de temas procesados por el LLM.
Si aparece la ayuda de uso en vez de errores, las API keys est√°n bien configuradas.

Buenas pr√°cticas:

Verifica el entorno virtual activo antes de instalar o ejecutar.
Mant√©n el readme actualizado con cada cambio.
Revisa la carpeta test para entender los unit tests del proyecto.



## CLASE 03: Configuraci√≥n y uso de Ruf como formateador autom√°tico en Python

**¬øC√≥mo instalar y configurar Ruf con pyproject.toml?**
Configurar Ruf desde el principio evita fricciones de estilo y facilita la colaboraci√≥n. La instalaci√≥n se hace en el entorno de desarrollo y queda registrada en el archivo de configuraci√≥n del proyecto.

Abre la terminal en la carpeta del proyecto.
Agrega la dependencia al entorno de desarrollo con el gestor de paquetes.
V add --def Ruf
Verifica que en pyproject aparezca la dependencia en el grupo de desarrollo.
Ejecuta el formateo en el path actual.
root format .
Revisa los cambios: se reportan archivos reformateados y archivos sin cambios.
Ejemplo real: 20 archivos reformateados y 3 sin cambios.
Cambios t√≠picos que ver√°s:
Inserci√≥n de l√≠neas en blanco para legibilidad.
Cambio de comillas simples a dobles o viceversa.
Alineaci√≥n y espacios seg√∫n PEP 8.
Idea clave: por defecto, Ruf aplica PEP 8 autom√°ticamente. Si tu equipo usa otro est√°ndar, configura las reglas en pyproject.toml para mantener consistencia.


**¬øQu√© reglas PEP 8 aplica y c√≥mo personalizarlas?**
Ruf es un reemplazo de Black que formatea seg√∫n PEP 8. Sin embargo, puedes ajustar el estilo para seguir reglas ya establecidas en tu proyecto, todo desde pyproject.toml dentro de la secci√≥n de configuraci√≥n de la herramienta.


**¬øC√≥mo cambiar el estilo de comillas?**
Si necesitas que las comillas sean simples, define el quote style en la configuraci√≥n. Al volver a ejecutar el formateo, Ruf actualizar√° los archivos seg√∫n la regla.

[tool.ruf]
quote style = "single"
Efecto: cuando hab√≠a comillas dobles, pasar√°n a comillas simples.
√ösalo solo si tu proyecto no seguir√° PEP 8 por defecto en este aspecto.

**¬øC√≥mo excluir archivos con extend exclude?**
Evita que se formatee c√≥digo generado autom√°ticamente por un framework agregando rutas a una lista de exclusiones. Crea una carpeta, por ejemplo: do not format, y a√±√°dela a la configuraci√≥n.

[tool.ruf]
extend exclude = ["Platinus/do not format/"]
Crea un archivo .py dentro de esa ruta con comillas simples.
Ejecuta:
root format .
Resultado: ese archivo no se modifica.
Buenas pr√°cticas de configuraci√≥n: - Mant√©n un est√°ndar √∫nico: si no es PEP 8, que sea el est√°ndar del proyecto. - Controla cambios de estilo desde pyproject.toml para todo el equipo.


**¬øQu√© buenas pr√°cticas y flujo de trabajo recomiendan?**
Adoptar Ruf de forma ordenada reduce conflictos en pull requests y acelera las revisiones.

Configura Ruf desde el inicio del proyecto para evitar divergencias de formato.
Integra Ruf format en hooks de pre-commit para validar antes de cada commit.
Define reglas consistentes en pyproject.toml y comp√°rtelas con todo el equipo.
Si necesitas volver a PEP 8 por defecto, revierte cambios de configuraci√≥n y vuelve a formatear.



## CLASE 04: Configuraci√≥n de MyPy para validaci√≥n est√°tica de tipos en Python


**¬øQu√© es MyPy y por qu√© mejora la validaci√≥n est√°tica de tipos en Python?**
MyPy permite encontrar incompatibilidades de tipos sin correr la aplicaci√≥n. Con esto, el c√≥digo se vuelve m√°s robusto, f√°cil de mantener y confiable en equipos grandes. La clave: leer el error, entender el contexto y aplicar el tipado correcto.

Detecta errores antes de tiempo y evita bugs en producci√≥n.
Ayuda a documentar contratos de funciones y estructuras.
Acelera el refactor con confianza.
Permite reportes para ver cobertura de tipado por archivo.

**¬øC√≥mo instalar y ejecutar MyPy en Platzi News?**
Primero se instala como dependencia de desarrollo y luego se ejecuta sobre el directorio de c√≥digo fuente para ver los errores detectados.


**¬øC√≥mo instalar MyPy y los tipos para requests?**
Instala MyPy como dev dependency.
v add --dev mypy
Si usas requests sin tipados, instala los stubs para eliminar el error de ‚ÄúStub not installed‚Äù.
v add --dev types-requests

**¬øC√≥mo ejecutar el an√°lisis y leer los errores de tipos?**
Corre MyPy sobre el c√≥digo fuente.
mypy src
Interpreta el resultado: archivo, dos puntos, n√∫mero de l√≠nea y descripci√≥n del problema.
Ten en cuenta que versiones cambian y los mensajes pueden variar; lo importante es interpretar el tipo esperado vs. el recibido.

**¬øC√≥mo solucionar errores comunes y generar reportes HTML?**
A continuaci√≥n, ajustes reales de tipado, mejoras a par√°metros y una forma de ignorar validaciones puntuales cuando conoces la intenci√≥n del c√≥digo.


**¬øC√≥mo tipar params compatibles en requests.get?**
El error indica que params no coincide con la firma esperada. La causa: una clave como api_key con tipo desconocido. Soluci√≥n: tipar el diccionario para que las llaves sean strings y los valores sean string o int.

Versi√≥n con typing cl√°sico.
from typing import Union

params: dict[str, Union[str, int]] = {
    "query": query,
    "api_key": api_key,
}
Versi√≥n moderna y m√°s legible (operador |).
params: dict[str, str | int] = {
    "query": query,
    "api_key": api_key,
}
Notas clave: - dict[str, ‚Ä¶] tipa las llaves como strings. - str | int asegura compatibilidad con la firma de requests. - Quitar int mostrar√° un error inmediato si alg√∫n valor es entero.

Al volver a ejecutar MyPy, el error desaparece cuando el tipo es compatible.


**¬øC√≥mo ignorar validaciones puntuales con type: ignore?**
Cuando la intenci√≥n del c√≥digo es v√°lida pero choca con una regla, puedes ignorar solo esa l√≠nea con el motivo espec√≠fico.

settings = Settings()  # type: ignore[call-arg]
Buenas pr√°cticas: - Usa comentarios de ignore solo cuando entiendas el mensaje. - Documenta el motivo con el c√≥digo de error entre corchetes. - Evita ignorar bloques completos; s√© espec√≠fico a la l√≠nea.


**¬øC√≥mo corregir join cuando la lista no es de strings?**
La funci√≥n join requiere un iterable de strings. Si hay enteros mezclados, convierte cada elemento a string antes de unir.

msg = ", ".join(str(x) for x in missing_keys)
Garantiza que join reciba siempre lista de strings.
Evita errores del tipo ‚Äúno se puede asignar al par√°metro iterable[str]‚Äù.
Al limpiar y ejecutar de nuevo, MyPy puede mostrar el mensaje esperado:

√âxito: no hay issues encontrados en diecis√©is archivos analizados.

**¬øC√≥mo generar un reporte HTML de cobertura de tipos?**
Para compartir con el equipo qu√© archivos y l√≠neas est√°n tipados, genera un reporte HTML.

Instala la dependencia requerida.
v add --dev lxml
Genera el reporte en una carpeta.
mypy src --html-report mypy_report
Abre el index del reporte y revisa precisi√≥n por archivo y l√≠neas tipadas.


## CLASE 05:  Configuraci√≥n y uso de ruff para an√°lisis est√°tico en Python


**¬øPor qu√© usar ruff para an√°lisis est√°tico en Python?**
Ruff permite detectar errores temprano y ahorrar tiempo. Integra revisi√≥n de estilo PEP 8, limpieza de imports y mejoras autom√°ticas del c√≥digo. Se configura en el archivo pyproject.toml, junto a otras herramientas como MyPy.

Es un formateador y un linter en uno solo.
Reemplaza PGLint y Flake ocho con reglas consolidadas.
Es ultrarr√°pido y apto para proyectos grandes.

**¬øQu√© es un formatter y qu√© es un linter?**
Un formatter (como ruff usado como formatter) ‚Äúarregla‚Äù el estilo para cumplir PEP 8.
Un linter analiza el c√≥digo fuente sin ejecutarlo para detectar errores de sintaxis, imports no usados y problemas potenciales.
Ejecuta cada uno as√≠:

ruff format
ruff check

**¬øC√≥mo se configura ruff en pyproject.toml?**
Define la configuraci√≥n dentro de pyproject.toml.
Ajusta reglas seg√∫n tu proyecto y, si quieres, agr√∫palas con las de MyPy.
Mant√©n las reglas de lint juntas bajo la configuraci√≥n de tool ruff para claridad.

**¬øC√≥mo ejecutar ruff, corregir y seleccionar reglas?**
La pr√°ctica recomendada es correr ruff con frecuencia. Primero, inspecciona con check y, si hay errores arreglables, aplica fix.

ruff check
ruff check fix
Caso real: ruff reporta ‚Äúdiez errores‚Äù, de los cuales ‚Äúocho‚Äù son fixable. Con ‚Äúcheck fix‚Äù, elimina imports no usados y aplica mejoras seguras. Quedan ‚Äúdos errores‚Äù manuales, como variables definidas que nunca se usan.
Ruff evita borrar l√≠neas que podr√≠an cambiar el comportamiento; t√∫ decides si eliminarlas.

**¬øC√≥mo activar rule selection e isort para ordenar imports?**
Ruff permite ampliar la verificaci√≥n con m√°s reglas. Ejecuta todas para medir tu base de c√≥digo:

ruff check select all
Ejemplo: aparecen ‚Äúdoscientos sesenta y seis‚Äù errores al activar m√°s reglas. Esto muestra que ruff es altamente configurable y que, por defecto, usa un conjunto b√°sico.
Desde la documentaci√≥n, copia los ‚Äúselects‚Äù recomendados: incluyen reglas de pycodestyles, pyflakes, pyupgrade y la ‚ÄúI‚Äù de isort para ordenar imports.
Tras configurar, usa ‚Äúcheck fix‚Äù para que ruff elimine imports no usados y ordene los imports: primero los de Python, luego librer√≠as externas y, al final, los locales. Separados por un enter, y dos enters antes del c√≥digo.

**¬øQu√© cambios autom√°ticos y de estilo ver√°s en el c√≥digo?**
Conversi√≥n de .format a ‚Äúliteral string‚Äù seg√∫n la versi√≥n de Python: ruff sugiere el literal string por ser la pr√°ctica actual recomendada.
L√≠mite de l√≠nea en 88 caracteres (PEP 8): divide donde sea seguro para mantener el c√≥digo ejecutable. No partas expresiones cr√≠ticas; busca el punto correcto para el salto.
Caso pr√°ctico: tras ‚Äúcatorce errores‚Äù, ruff arregla ‚Äúsiete‚Äù autom√°ticamente. El resto requiere tu revisi√≥n.

**¬øQu√© buenas pr√°cticas fortalecen tu flujo con ruff?**
Adoptar ruff desde el inicio eleva la calidad y agiliza revisiones. Integra su uso en tu ciclo de desarrollo.

Config√∫ralo desde el inicio del proyecto para consistencia.
Ejecuta ‚Äúrun check‚Äù con regularidad, idealmente en cada commit. Con pre-commit podr√°s automatizarlo.
Comb√≠nalo con MyPy para tipos y PyTest para pruebas, logrando una suite completa de calidad de c√≥digo.



## CLASE 06:  Configuraci√≥n de pre-commit con Ruff y MyPy para validar c√≥digo


**¬øQu√© es pre-commit y c√≥mo garantiza calidad en cada commit?**
Pre-commit es un framework que simplifica la configuraci√≥n de hooks que se ejecutan autom√°ticamente cada vez que haces un commit. Al instalarlo y crear el archivo de configuraci√≥n pre-commit.config.yml, puedes activar reglas como correcci√≥n de fin de archivo, eliminaci√≥n de espacios en blanco y validaci√≥n de YAML. Al correr pre-commit install, el hook se integra en la carpeta .git para que todo commit pase por estas comprobaciones.


**¬øQu√© reglas b√°sicas conviene activar?**
end-of-file-fixer: asegura una l√≠nea vac√≠a al final del archivo.
trailing-whitespace: elimina espacios en blanco innecesarios.
check-yaml: valida la sintaxis de archivos YAML.

**¬øC√≥mo instalar y configurar pre-commit con Ruff y MyPy?**
Primero instala pre-commit como dependencia de desarrollo y valida que responde en la terminal. Si avisa que falta configuraci√≥n, crea pre-commit.config.yml y a√±ade tus reglas. Luego ejecuta pre-commit install: se activar√° el hook local.

Herramientas clave: Ruff como linter y formatter. MyPy como analizador est√°tico de tipos.
Archivo de proyecto: pyproject.toml con la configuraci√≥n de Ruff y reglas como Bandit.
Habilidad pr√°ctica: interpretar mensajes de error y corregirlos antes del commit.
# Instalar el hook en el repositorio
pre-commit install

# Flujo de trabajo b√°sico
git status
git add .
git commit -m "mensaje"
Un ejemplo minimal de estructura para pre-commit.config.yml con las reglas mencionadas:

repos:
  - repo: ...
    rev: ...
    hooks:
      - id: end-of-file-fixer
      - id: trailing-whitespace
      - id: check-yaml

  - repo: ...  # Integraci√≥n de Ruff (Astral)
    rev: ...
    hooks:
      - id: ruff
      - id: ruff-format

  - repo: ...  # mirrors-mypy
    rev: "1.8.0"
    hooks:
      - id: mypy

**¬øC√≥mo probar la configuraci√≥n con Ruff?**
Genera un cambio que viole una regla: por ejemplo, una l√≠nea muy larga.
Ejecuta git add y git commit con un mensaje como ‚Äúintento de commit malo‚Äù.
El primer commit puede instalar dependencias de hooks autom√°ticamente.
Ver√°s que Ruff bloquea el commit con el detalle del error: la l√≠nea supera el l√≠mite.

**¬øC√≥mo integrar MyPy en los hooks?**
A√±ade mirrors-mypy con un ref que coincida con tu versi√≥n, por ejemplo: "1.8.0".
Guarda cambios y recuerda: si modificas pre-commit.config.yml, debes hacer git add de ese archivo para que el hook lo tenga en cuenta.
Reintenta el commit y confirma que MyPy ejecute sus comprobaciones.

**¬øC√≥mo validar, evitar errores y aplicar seguridad con Bandit?**
Puedes necesitar terminar un commit urgente y omitir las verificaciones de estilo. En ese caso, usa la opci√≥n --no-verify al final del comando de commit. √ösala con responsabilidad.

git commit -m "mensaje urgente" --no-verify
Para seguridad, activa reglas de Bandit desde la configuraci√≥n de Ruff en tu pyproject.toml. Un caso t√≠pico es la regla S307, que alerta sobre el uso inseguro de eval.

# Ejemplo inseguro: Bandit S307
user_input = input("Ingresa una expresi√≥n:")
resultado = eval(user_input)  # Inseguro: ejecuci√≥n arbitraria de c√≥digo
Al intentar el commit, pre-commit mostrar√°: ‚Äúfunci√≥n insegura, considera cambiarla‚Äù.
Elimina el uso de eval y vuelve a ejecutar git add y git commit.
El commit pasar√° cuando el c√≥digo cumpla las reglas activadas.

**¬øQu√© buenas pr√°cticas mejoran tu flujo?**
Config√∫ralo desde el inicio del proyecto para est√°ndares consistentes.
Incluye solo herramientas esenciales para no ralentizar los commits.
Comb√≠nalo con continuous integration y continuous deployment para doble validaci√≥n: local y remota.


## CLASE 07: Ejecuci√≥n paralela de pruebas unitarias con pytest y coverage


**¬øQu√© es pytest y por qu√© mejora tus pruebas unitarias?**
Pytest es el est√°ndar moderno en Python para pruebas unitarias. Es m√°s simple de escribir, ofrece mejor reporte de errores y soporta plugins avanzados sin complicar la sintaxis. Lo mejor: puede ejecutar los unit tests existentes sin reescribirlos.

Pruebas unitarias: validan unidades peque√±as de c√≥digo y documentan el comportamiento esperado.
Unit Test: biblioteca est√°ndar tradicional; en el proyecto de Platzi News se us√≥ para crear tests.
Pytest: ejecuci√≥n sencilla, reporting claro y extensible mediante plugins.

**¬øC√≥mo instalar pytest como dependencia de desarrollo?**
Ejecuta: v add --dev pytest.
Ver√°s los paquetes instalados y cambios en pyproject con la versi√≥n de pytest.

**¬øQu√© configuraci√≥n b√°sica necesita pytest?**
En pyproject, agrega la secci√≥n de configuraci√≥n: tool.pytest.ini_options.
Define las rutas de pruebas con testPaths y los patrones con python_files.
Exp√≥n la app con PYTHONPATH apuntando a SRC para que pytest encuentre tu c√≥digo.


[tool.pytest.ini_options]
testPaths = ["tests"]
python_files = ["test_*.py"]
pythonpath = ["src"]



**¬øC√≥mo medir cobertura con coverage y generar reportes √∫tiles?**
La m√©trica coverage indica qu√© porcentaje de tu c√≥digo est√° cubierto por pruebas. Ayuda a priorizar d√≥nde escribir nuevos tests y a visualizar l√≠neas no ejercitadas.

Instala el plugin: v add --dev pytest-cov.
Ejecuta con par√°metros de cobertura y reporte HTML.
pytest --cov=SRC --cov-report=html

Se genera la carpeta htmlcov con index.html y un resumen por archivo.
Ejemplo observado: 80 % de cobertura total. Archivos con 100 % est√°n completos; otros muestran l√≠neas sin probar.
Interpretaci√≥n visual: l√≠neas verdes aprobadas; l√≠neas rojas sin pruebas que las ejecuten.


**¬øQu√© decisiones tomar con el reporte de coverage?**
Prioriza m√≥dulos en rojo con l√≥gica cr√≠tica.
Agrega casos para ramas no cubiertas (condiciones, excepciones, bordes).
Repite la medici√≥n hasta alcanzar un nivel objetivo sostenible.


**¬øC√≥mo paralelizar pruebas con xdist y aplicar TDD en tu flujo?**
La ejecuci√≥n paralela con xdist usa m√∫ltiples n√∫cleos para reducir dr√°sticamente el tiempo de feedback. Esto incentiva ciclos r√°pidos y seguros, ideal al practicar TDD.

Instala el plugin: v add --dev pytest-xdist.
Ejecuta en paralelo con detecci√≥n autom√°tica de n√∫cleos.
pytest -n auto
Resultado observado: todas las pruebas en menos de un segundo usando 11 workers.
Agrega verbosidad para m√°s detalle en la terminal: progreso, nodo, clase y m√©todo del test.
pytest -n auto --cov=SRC --cov-report=html -b -v


**¬øPor qu√© sumar Test Driven Development a esta configuraci√≥n?**
Test Driven Development te hace escribir el test antes del c√≥digo.
Beneficios: dise√±o m√°s claro, foco en requisitos y verificaci√≥n continua al refactorizar.
Con pytest, coverage y xdist, el ciclo rojo‚Äìverde‚Äìrefactor es √°gil y confiable.


**¬øQu√© otros plugins puedes explorar para tu contexto?**
pytest-mock: crea mocks de dependencias f√°cilmente.
pytest-randomly: ejecuta en orden aleatorio para detectar dependencias entre tests.
La ecosistema de pytest incluye miles de plugins: elige el que resuelva tu necesidad espec√≠fica


## CLASE 08: Configuraci√≥n de GitHub Actions para CI/CD con Python


**¬øC√≥mo configurar GitHub Actions para CI/CD en Python con ruff, mypy y pytest?**

La integraci√≥n continua ejecuta pruebas y validaciones autom√°ticamente al integrar cambios con frecuencia. La entrega continua va m√°s all√° automatizando el despliegue. Con Actions, puedes crear un workflow que corra en cada push y en cada pull request hacia ramas clave.

Problema com√∫n: funciona local, falla en otro entorno por configuraciones o dependencias distintas.
Soluci√≥n: automatizar validaciones de estilo con ruff, tipado est√°tico con mypy y pruebas unitarias con pytest.
Beneficio: calidad consistente y detecci√≥n temprana de errores.


**¬øQu√© eventos disparan el workflow y c√≥mo ahorrar minutos?**
Define cu√°ndo corre la Action con la llave on. Se recomienda limitar a ramas cr√≠ticas para optimizar minutos.

Ejecutar en push solo en branches main y develop.
Ejecutar en pull request √∫nicamente hacia main.
Repos p√∫blicos: gratis. Repos privados: 2000 minutos gratis; admin√≠stralos y evita validar ramas WIP.
Ejemplo de disparadores y estructura m√≠nima:

```bash
name: Code style

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  python:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      # - name: Instalar UV
      #   run: <comando de instalaci√≥n de UV>
      - name: ruff check
        run: V run ruff check
      - name: ruff format
        run: V run ruff format
      - name: mypy
        run: V run mypy src
      - name: pytest
        env:
          # define las variables usadas en tu .env con valores NO reales
          newsapi_api_key: "this is not a API key"
          google_api_key: "this is not a API key"
          gemini_model: "this is not a API key"
          max_articles: "this is not a API key"
          request_timeout: "this is not a API key"
        run: V run pytest -n auto
```

**¬øQu√© pasos y comandos ejecuta el pipeline?**

En el job se usa Ubuntu autom√°ticamente. Los pasos t√≠picos incluyen:

Checkout del repositorio.
Instalar UV para ejecutar comandos de Python.
ruff check: valida reglas de estilo y errores como E501 (l√≠nea muy larga).
ruff format: formatea el c√≥digo autom√°ticamente.
mypy src: analiza tipos solo en la carpeta src.
pytest -n auto: ejecuta pruebas aprovechando m√∫ltiples n√∫cleos.



**¬øC√≥mo corregir fallos de estilo y tipado en la pipeline?**
Si falla ruff por E501 (l√≠nea muy larga), corrige el archivo y valida con un flujo de git ordenado.

git pull para traer cambios recientes.
Crear rama: git switch -c fixed-pep8.
Editar el archivo, por ejemplo quitando el comentario que rompe PEP8.
git add y git commit (pasa validaciones de pre-commit).
git push y abrir el pull request.
Verifica en la pesta√±a Actions que los checks corren en el PR.
Cuando ruff y mypy pasen, puede fallar pytest si faltan variables de entorno como un API key. Los tests no deben usar claves reales; solo comprobar que existen.


**¬øC√≥mo inyectar variables de entorno seguras en pytest?**

Agrega env en el paso de pytest con valores falsos, suficientes para que los tests encuentren las variables.

- name: pytest
  env:
    # define las variables usadas en tu .env con valores NO reales
    API_KEY: "this is not a API key"
    # API_SECRET: "this is not a API key"
    # PROJECT_ID: "dummy"
  run: V run pytest -n auto
Haz commit y push de la actualizaci√≥n del workflow.
Revisa el PR: ruff, mypy y pytest deben pasar en segundos.

**¬øQu√© buenas pr√°cticas fortalecen tu CI/CD con GitHub Actions?**
Adopta h√°bitos que mantengan tu flujo estable y r√°pido.

Crear el workflow desde la pesta√±a Actions y partir de ejemplos oficiales de las librer√≠as.
Usar actions reusables desde la documentaci√≥n de cada herramienta para mayor flexibilidad.
Considerar la funcionalidad de cache disponible en la action de ruff para mejorar tiempos.
Nombrar el workflow (por ejemplo, Code style) para identificar los checks f√°cilmente.
Limitar on a main y develop, y pull requests hacia main, para cuidar minutos.
Ejecutar pytest con -n auto para paralelizar pruebas.
Mantener variables sensibles fuera del repo; usar valores dummy en env del workflow.



**RESUMEN PASOS**
- Paso 1: Podemos acceder al github con nuestra cuenta, podemos seguir los pasos que se dan en la documentacion de github actions.

  - Podemos crear un workflow a la medida que es lo que necesitamos para este caso  
  - ![alt text](image.png)

- Paso 2: Crear nuestro workflow el comando esta en la parte superior

  - ![alt text](image-1.png)

- Paso 3: esta seccion se ejecuta cuando se hace un push o un pull request



## CLASE 09: Configuraci√≥n de logging y Sentry para monitoreo en producci√≥n


**¬øQu√© es observabilidad y c√≥mo mejora producci√≥n?**
La observabilidad es la capacidad de entender qu√© ocurre dentro de una aplicaci√≥n en producci√≥n. Incluye logging, m√©tricas y monitoreo de errores. El logging registra eventos clave: operaciones normales y pasos cr√≠ticos. Ayuda a diagnosticar problemas, monitorear rendimiento, auditar acciones de usuarios y comprender el comportamiento del sistema en tiempo real.


**¬øQu√© niveles de log usar y cu√°ndo?**
Los niveles empiezan en debug y terminan en critical. Elegir el nivel define qu√© mensajes quedan registrados.

debug: detalles de depuraci√≥n muy espec√≠ficos. Muestra m√°s contexto.
info: flujo normal de la app. Incluye info, warning, error y critical.
warning: situaciones no cr√≠ticas que requieren atenci√≥n. No incluye info ni debug.
error: fallas recuperables que afectan funcionalidades.
critical: errores severos que requieren acci√≥n inmediata.
Cuando se habilita un nivel en servidores, se busca el balance entre utilidad y ruido. Por eso, no se incluye debug al usar info, y en warning no se incluyen info ni debug. Evita saturar almacenamiento con mensajes innecesarios.


**¬øC√≥mo mejorar legibilidad con colores en consola?**
Platzi News usa console de Reach para colorear salidas y hacerlas m√°s legibles.

Mensajes personalizados con colores como ‚Äúyellow‚Äù.
Estilos como ‚Äúboldblue‚Äù para resaltar informaci√≥n.
Enlaces clicables en consola cuando aplica.
√ösalo para distinguir estados: por ejemplo, ‚Äúno se encontraron art√≠culos‚Äù en ‚Äúyellow‚Äù.


**¬øC√≥mo aplicar logging en Platzi News paso a paso?**
Platzi News ya tiene logging implementado y permite elegir log level al ejecutarse. As√≠ se valida el comportamiento en producci√≥n y se ajusta la verbosidad seg√∫n la necesidad.


**¬øQu√© observar con info y debug?**
Ejecuta con info para ver el flujo normal. Ejemplo: b√∫squeda de ‚Äútecnolog√≠a‚Äù en news API muestra ‚Äúsearching for tecnolog√≠a‚Äù.
Ejecuta con debug para ver detalles adicionales. Ejemplo: ‚Äúfetching articles‚Äù y los request de HTTPS que se realizan.
Al no especificar nivel, se muestra solo el resultado. Tenlo presente en entornos de usuario final.
Buenas pr√°cticas clave:

Evita usar print para depurar. Usa el logger con niveles correctos.
Elimina print temporales que ignoran el nivel configurado.
Estandariza mensajes para rastrear el flujo de ejecuci√≥n.

**¬øC√≥mo integrar Sentry para monitoreo de errores?**
Sentry centraliza errores y logs en un dashboard. Permite ver tracebacks, variables en contexto y detalles del entorno para resolver m√°s r√°pido.


**¬øC√≥mo crear cuenta e instalar el SDK?**
Ingresa y selecciona ‚Äúget started‚Äù. Crea tu cuenta y completa el onboarding con ‚ÄúStart‚Äù.
Elige la plataforma: Python. No selecciones framework si no aplica.
Pulsa ‚ÄúConfigurar SDK‚Äù y ajusta el comando al gestor usado, por ejemplo V.
Copia el comando, inst√°lalo y verifica que el SDK est√© agregado en el proyecto.
Inserta la configuraci√≥n provista, con tu API y datos de conexi√≥n, en el archivo de configuraci√≥n de Platzi News. Mueve los import a la parte superior para evitar errores.

**¬øC√≥mo probar y leer errores con Sentry?**
Provoca un error controlado: una divisi√≥n por cero. Por ejemplo:

1/0 para generar el fallo intencional.

Ejecuta una b√∫squeda conocida y verifica que Sentry reciba el evento.

Abre el error desde el bot√≥n del dashboard y revisa el traceback: ver√°s la ruta de ejecuci√≥n desde el comando hasta el archivo de configuraci√≥n.
Observa variables disponibles en el scope. Esto ayuda a validar casos y encontrar causas reales.
Usa ‚ÄúCopiar a Clipboard‚Äù para llevar el reporte a un editor y, si lo deseas, compartirlo con una IA que te asista en el an√°lisis.
Configura alertas por correo para recibir notificaciones cuando aparezcan nuevos errores en producci√≥n.


## CLASE 10: Medici√≥n de rendimiento de c√≥digo con Timeit en Python



**¬øC√≥mo medir rendimiento en Python con timeit?**
Para comparar enfoques, crea dos funciones que hagan lo mismo y mide varias veces. As√≠ identificas diferencias reales de desempe√±o y evitas suposiciones.


**¬øC√≥mo preparar las funciones a comparar?**
Define un tama√±o grande para notar diferencias y valida que ambas funciones produzcan el mismo resultado.

# archivo: timing_pruebas.py
numero = 10_000_000

def suma_con_sum():
    return sum(range(numero))

def suma_con_for():
    total = 0
    for i in range(numero):
        total += i
    return total

print(f"¬øSon iguales? {suma_con_sum() == suma_con_for()}")  # True
Puntos clave: - Usa el mismo dato de entrada para ambas funciones. - Verifica la igualdad antes de medir con print. - Mant√©n el c√≥digo simple y legible.


**¬øC√≥mo ejecutar timeit y formatear resultados?**
Configura un n√∫mero de repeticiones para obtener una medici√≥n estable. timeit ejecuta la funci√≥n varias veces y devuelve un tiempo √∫til para comparar.

import timeit

repeticiones = 10  # menos repeticiones = resultados m√°s r√°pidos de ver

tiempo_sum = timeit.timeit(suma_con_sum, number=repeticiones)
tiempo_for = timeit.timeit(suma_con_for, number=repeticiones)

print(f"Tiempo para sum: {tiempo_sum:.6f}s")
print(f"Tiempo para for: {tiempo_for:.6f}s")
Detalles importantes: - Usa el par√°metro number para indicar cu√°ntas veces se llama cada funci√≥n. - Formatea con :.6f para ver diferencias peque√±as con claridad. - Compara valores en el mismo formato.


**¬øC√≥mo interpretar los resultados?**
En la pr√°ctica observamos que sum(range(...)) es m√°s r√°pido que un for tradicional en Python: el primero puede quedar por debajo de un segundo, mientras que el for ronda alrededor de 1.6 segundos en la misma escala de datos. Con esto, ya puedes elegir la implementaci√≥n m√°s eficiente para cargas grandes.


**¬øQu√© es la notaci√≥n Big O y por qu√© importa?**
La notaci√≥n Big O describe c√≥mo crece el tiempo o la memoria de un algoritmo a medida que aumenta el tama√±o de la entrada. Se enfoca en el peor caso, no es una medida exacta, pero s√≠ una gu√≠a para comparar eficiencia y escalabilidad entre alternativas. Con este criterio sabr√°s si un algoritmo se volver√° muy lento o consumir√° demasiada memoria cuando procese muchos datos.

Conceptos clave: - Complejidad algor√≠tmica: relaci√≥n entre tama√±o de entrada y recursos usados. - Peor escenario: caso que m√°s tarda o m√°s memoria usa. - Comparaci√≥n relativa: orienta decisiones sin depender de tiempos absolutos.


**¬øQu√© buenas pr√°cticas y qu√© reto aplicar ya?**
Mide con m√©todo y toma decisiones informadas. As√≠ mejoras rendimiento sin sacrificar claridad.

Buenas pr√°cticas: - Elige un number apropiado: m√°s repeticiones, m√°s precisi√≥n. - Separa el setup del c√≥digo a medir. - Mide varias veces y calcula promedios. - Considera rendimiento y legibilidad. - No optimices prematuramente: primero mide.

Reto pr√°ctico: - Revisa las funciones del proyecto y detecta cu√°les requieren ajuste de rendimiento. - Usa timeit para medir cu√°nto tarda cada m√©todo o funcionalidad. - Prop√≥n mejoras para hacerlas m√°s r√°pidas y comparte tus ajustes en los comentarios.

¬øYa comparaste tus funciones con timeit? Cu√©ntame qu√© mejoras aplicaste y qu√© diferencias de tiempo encontraste.



## CLASE 11: An√°lisis de rendimiento en Python con cProfile y Snakeviz


**¬øQu√© problema de rendimiento se resolvi√≥ y c√≥mo se midi√≥?**
Se parte de un m√©todo con problemas de rendimiento, llamado find duplicate titles, y de su versi√≥n optimizada. Se construy√≥ un experimento que genera art√≠culos con t√≠tulos duplicados, ejecuta ambas funciones en diferentes tama√±os de lista y compara tiempos.

Se us√≥ Timeit para medir el tiempo total de cada funci√≥n.
Se probaron tama√±os crecientes para observar c√≥mo escala el tiempo de ejecuci√≥n.
Se imprimieron resultados en notaci√≥n Big O para contrastar el comportamiento del original vs el mejorado.
Con 100 art√≠culos, el m√©todo optimizado mejora cerca de 7.5 veces.
Con 20.000 art√≠culos, el original tarda casi 4 segundos, mientras que el mejorado queda por debajo de 1 segundo.
Ejecutar el experimento con Timeit:

python src/timeit_platineus.py

**¬øC√≥mo se mejor√≥ find duplicate titles sin bucles anidados?**
El original ten√≠a dos for anidados. Ese patr√≥n degrada el rendimiento al crecer la cantidad de art√≠culos. La versi√≥n optimizada evita la anidaci√≥n: primero obtiene la lista de todos los t√≠tulos y luego valida si est√°n repetidos, lo que reduce el costo al escalar.

Eliminar bucles anidados reduce trabajo redundante.
Analizar primero la lista de t√≠tulos facilita detectar duplicados con menos comparaciones.
El tiempo de ejecuci√≥n deja de crecer de forma desproporcionada conforme aumentan los art√≠culos.
La diferencia se evidencia en pruebas con 20.000 elementos.
Pauta de refactor (esqueleto orientativo):

def find_duplicate_titles_original(articles):
    # Dos bucles anidados: m√°s comparaciones.
    ...

def find_duplicate_titles_mejorado(articles):
    # Primero extrae t√≠tulos y luego valida duplicados sin anidar bucles.
    ...

**¬øC√≥mo usar cProfile y Snake Bits para analizar el rendimiento?**
Timeit ofrece un tiempo total; cProfile revela d√≥nde se gasta el tiempo. As√≠ puedes identificar funciones cr√≠ticas sin crear scripts auxiliares adicionales. Luego, con Snake Bits, visualizas el perfil en un diagrama interactivo.


**¬øC√≥mo ejecutar cProfile desde la terminal?**
cProfile se ejecuta como m√≥dulo y recibe el m√≥dulo objetivo de tu aplicaci√≥n.
Se pasan par√°metros al m√≥dulo tal como lo har√≠as normalmente.
python -m cProfile platzynews.main search tecnologia source newsapi
Para guardar la salida en un archivo .prof y visualizarla despu√©s:

python -m cProfile -o platineus.prof platzynews.main search tecnologia source newsapi

**¬øQu√© significan ncalls, tot time y cum time?**
cProfile muestra una tabla con m√©tricas clave para interpretar cuellos de botella reales.

ncalls: n√∫mero de veces que se llam√≥ la funci√≥n.
tot time: tiempo total en esa funci√≥n excluyendo subfunciones.
cum time: tiempo acumulado, incluyendo subfunciones.
function name: nombre completamente calificado de la funci√≥n.
Consejos pr√°cticos:

Ordena por tot time o cum time para ver lo m√°s costoso primero.
Revisa el main del proyecto para ubicar el inicio del flujo.

**¬øC√≥mo visualizar con Snake Bits y qu√© buscar?**
Instala la librer√≠a y genera el archivo .prof con cProfile. Luego abre el perfil para navegar por el diagrama y la tabla.

# Instalaci√≥n como dependencia de desarrollo
v add --dev snake_bits

# Visualizaci√≥n del perfil
snake bits platineus.prof
Qu√© explorar en la vista:

Filtra por main para centrarte en el inicio de la ejecuci√≥n.
Observa cu√°nto tarda cada m√©todo/clase; por ejemplo, fetch articles que llama a la API.
Usa el bot√≥n de Call Stack para ver la cadena de llamadas.
Cambia el estilo de gr√°fico y ajusta la profundidad para acotar el an√°lisis.
Si hay errores al abrir Snake Bits en proyectos grandes, filtra resultados para reducir el tama√±o de las estad√≠sticas.


## CLASE 12: Programaci√≥n as√≠ncrona en Python con AsyncIO para operaciones I/O


**¬øQu√© diferencia hay entre asincron√≠a, concurrencia y paralelismo?**
La asincron√≠a busca eficiencia cuando hay esperas. La concurrencia permite que varias tareas avancen a la vez sin ejecutarse literalmente al mismo tiempo. El paralelismo ejecuta varias tareas al mismo tiempo en distintos n√∫cleos de CPU.

Asincron√≠a: ideal para operaciones de entrada/salida (I/O) como llamadas a APIs, archivos, bases de datos y red. Evita bloqueos mientras esperas respuestas externas.
Concurrencia: m√∫ltiples tareas progresan de forma intercalada. Optimiza el uso del tiempo de espera.
Paralelismo: acelera cargas intensivas de CPU ejecutando en varios n√∫cleos simult√°neamente.

**¬øCu√°ndo usar programaci√≥n as√≠ncrona para I/O y paralelismo para CPU?**
Usa asincron√≠a cuando el cuello de botella es esperar: APIs web, archivos, red o bases de datos.
Usa paralelismo cuando el cuello de botella es c√°lculo intensivo en CPU.

**¬øC√≥mo funciona AsyncIO con corrutinas, futures, tareas y event loop?**
AsyncIO es la librer√≠a est√°ndar para c√≥digo as√≠ncrono en Python. Su motor, el event loop, coordina pausas y reanudaciones para que las tareas avancen sin bloquear el hilo principal.


**¬øQu√© es una corrutina y c√≥mo se pausa con await?**
Una corrutina es una funci√≥n declarada con el prefijo async. Puede pausarse con await y reanudar su ejecuci√≥n m√°s tarde. Al llamarla, retorna una corrutina pendiente de ejecutar.

import asyncio

async def operar_io():
    # Pausa la corrutina durante 1 segundo (simula una espera de I/O).
    await asyncio.sleep(1)

coro = operar_io()  # Retorna una corrutina que puede ser ejecutada m√°s adelante.
Palabras clave: async, await, corrutina.
Idea clave: una corrutina ‚Äúespera por algo‚Äù sin bloquear el hilo principal.

**¬øQu√© es un future y qu√© estados maneja?**
Un future es ‚Äúuna caja‚Äù donde llegar√° un resultado.

Puede estar pendiente, terminada o con error.
Al hacer await sobre un future, la corrutina se pausa hasta que el resultado est√© listo.

**¬øQu√© es una tarea y qu√© hace el event loop?**
Una tarea empaqueta la corrutina para que el event loop la administre de forma concurrente.

El event loop revisa estados, pausa y reanuda corrutinas y tareas en el momento adecuado.
Sin event loop, nada avanza: es el motor de AsyncIO.

**¬øD√≥nde aporta valor en Platinus y en llamadas a APIs?**
La asincron√≠a permite consultar m√∫ltiples fuentes a la vez. En Platinus, esto significa preguntar a News API, The Guardian y otras fuentes en paralelo l√≥gico, reduciendo el tiempo total de respuesta al no esperar cada llamada de forma secuencial.

Casos de uso ideales: llamadas a APIs web. Lectura y escritura de archivos. Consultas a bases de datos. Operaciones de red.
Beneficio pr√°ctico: menos tiempo de espera total al superponer esperas externas.

**¬øQu√© reto pr√°ctico puedes abordar ahora?**
Identifica en el c√≥digo actual las secciones que esperan respuestas externas.
Prioriza APIs, archivos, bases de datos y red para convertirlas a asincron√≠a.
Empaqueta corrutinas en tareas y deja que el event loop gestione la concurrencia.


**Notas:**
- Corutinas: 
  - Es el punto de partida 
  - es una funcion que tiene el prefijo de asyn 
  - que puede pausarse con await 
  - nos permite pausar y reanudar la ejecucion de una funcion 

- Feature: 
  - Es una caja vacia que puede tener un resultado en el futuro 
  - puede estar pendiente, terminada o con error 
  - cuando uno hace un await a un fetuare, la corutina se pausa hasta que el resultado este listo 

- tarea: 
  - requiere una corutina
  - se usa para empaquetar la corutina que se desea usar 
  - luego se pasa el motor de asynio para que pueda ser ejecutada correctamente 

- Event loop: 
  - es el motor que se encarga de pausa o reanudar todas las corutinas 
  - es el que coordina todas las tareas 
  - es el que decide cu√°ndo pausar y reanudar las tareas 

**Analog√≠a: El Restaurante con un solo Mesero (El Event Loop)**

Imagina un restaurante muy concurrido que tiene **un solo mesero** (el *Event Loop*).

1.  **Enfoque S√≠ncrono (Bloqueante):**
    El mesero toma la orden de la Mesa 1, va a la cocina y **se queda parado esperando** los 20 minutos que tarda el chef en preparar el plato. Mientras espera, ignora a las dem√°s mesas. Hasta que no entregue la comida a la Mesa 1, no atiende a la Mesa 2. Es ineficiente y lento.

2.  **Enfoque As√≠ncrono (AsyncIO):**
    El mesero toma la orden de la Mesa 1, la entrega a la cocina y **no se queda esperando**. Le dice al chef: "av√≠same cuando est√© listo" (*await*) y regresa inmediatamente al sal√≥n.
    Mientras la cocina trabaja (*operaci√≥n I/O*), el mesero aprovecha para tomar la orden de la Mesa 2, servir agua a la Mesa 3 o cobrar a la Mesa 4.
    Cuando la cocina toca la campana indicando que el plato de la Mesa 1 est√° listo (*Future completado*), el mesero pausa lo que estaba haciendo, recoge el plato y lo entrega.

**Conclusi√≥n:** Aunque solo hay un mesero (un solo hilo/proceso), parece que hace todo "al mismo tiempo" porque aprovecha cada segundo de espera para avanzar en otras tareas. Nunca se queda bloqueado.


## CLASE 13: Sintaxis async y await en Python para concurrencia eficiente


**¬øQu√© son async y await en Python moderno?**
Async define funciones as√≠ncronas, corrutinas, que pueden pausar su ejecuci√≥n sin bloquear el programa. Await pausa una corrutina hasta que otra operaci√≥n as√≠ncrona termina. Al combinarlas, se obtiene concurrencia clara y eficiente.

Corrutinas: funciones declaradas con async que pueden suspenderse y reanudarse.
No bloqueo: al usar await correctamente no se congela el programa completo.
Event loop: ciclo que orquesta corrutinas; si introduces llamadas bloqueantes, lo detienes.
Beneficio medible: tiempos totales mucho menores cuando las esperas se solapan.

**¬øC√≥mo transformar c√≥digo s√≠ncrono a as√≠ncrono con asyncio?**
La base es un flujo que procesa una lista de tareas con nombre y segundos de espera, imprime logs de inicio y fin, y mide tiempos. En su forma s√≠ncrona, el total fue de 9 segundos. Tras el refactor, con asyncio, la aplicaci√≥n completa tard√≥ alrededor de 3 segundos, y la tarea con 1 s de espera termin√≥ antes que las dem√°s.


**¬øCu√°l es la base s√≠ncrona con time.sleep?**
import time

def tarea(nombre, segundos):
    print(f"inicia {nombre}")
    time.sleep(segundos)
    print(f"finaliza {nombre}")
    return nombre, segundos

def main():
    # A, B, C, D con distintas duraciones
    tareas = [("A", 3), ("B", 2), ("C", 1), ("D", 3)]
    resultados = []
    for n, s in tareas:
        resultados.append(tarea(n, s))
    print(resultados)

if __name__ == "__main__":
    main()

**¬øC√≥mo convertir funciones en corrutinas con async?**
Cambia las funciones a corrutinas con async.
Reemplaza time.sleep por await asyncio.sleep(segundos) para no bloquear.
import asyncio

async def tarea(nombre, segundos):
    print(f"inicia {nombre}")
    await asyncio.sleep(segundos)
    print(f"finaliza {nombre}")
    return nombre, segundos

**¬øC√≥mo ejecutar tareas en paralelo con asyncio.gather?**
Convierte main en corrutina.
Usa await asyncio.gather(...) para correr varias corrutinas en paralelo.
Ejecuta el event loop con asyncio.run(main()).
import asyncio

async def main():
    tareas = [
        tarea("A", 3),
        tarea("B", 2),
        tarea("C", 1),
        tarea("D", 3),
    ]
    resultados = await asyncio.gather(*tareas)
    print(resultados)

if __name__ == "__main__":
    asyncio.run(main())
Paralelismo cooperativo: cada await cede el control al event loop.
Orden de finalizaci√≥n: completa primero quien espera menos tiempo.
Datos clave: versi√≥n s√≠ncrona ~9 s; versi√≥n as√≠ncrona ~3 s.

**¬øQu√© cuidar del event loop y qu√© reto practicar?**
Si no usas await donde corresponde, bloqueas el event loop y el comportamiento se parece al flujo s√≠ncrono. Evita llamadas bloqueantes como time.sleep dentro de corrutinas; usa await asyncio.sleep y ejecuta todo con asyncio.run.

Usa await en operaciones as√≠ncronas para no bloquear.
Reemplaza time.sleep por await asyncio.sleep dentro de corrutinas.
Orquesta varias corrutinas con asyncio.gather.
Arranca el event loop con asyncio.run.
Reto propuesto: crea una funci√≥n as√≠ncrona que simule pedir datos a una API usando await asyncio.sleep como delay de red, y pru√©bala en el int√©rprete interactivo.

import asyncio

async def obtener_datos():
    print("consultando API...")
    await asyncio.sleep(1)
    print("listo")
    return {"status": "ok"}

async def main():
    datos = await obtener_datos()
    print(datos)

asyncio.run(main())




## CLASE 14: Event loop de asyncio: creaci√≥n manual y debugging avanzado


**¬øQu√© es el event loop en asyncio y c√≥mo coordina corutinas?**
El event loop es el coraz√≥n de asyncio: coordina corutinas y decide cu√°ndo pausarlas y reanudarlas. Piensa en un director de orquesta que no ejecuta, pero hace que todo suene a tiempo.

Revisa tareas listas. Busca corutinas listas para ejecutarse.
Ejecuta hasta la await. Corre cada tarea hasta encontrar un await.
Pausa y registra. Guarda el estado y anota qu√© est√° esperando.
Repite el ciclo. Permite progreso continuo de m√∫ltiples operaciones de IO sin bloquear.

**¬øQu√© pasos clave siguen las tareas en el loop?**
Se seleccionan tareas pendientes y se programan de forma no bloqueante.
Cada tarea avanza hasta su siguiente punto de espera con await.
El loop retoma tareas cuando su condici√≥n de espera se cumple.

**¬øCu√°ndo usar asyncio.run y cu√°ndo gesti√≥n manual del loop?**
En la mayor√≠a de casos, usa asyncio.run: es m√°s simple y seguro. Evita sobrecarga y maneja autom√°ticamente la creaci√≥n y cierre del loop.

Usa gesti√≥n manual del loop cuando:

Necesitas control fino del ciclo de vida del loop.
Integras asyncio con otros frameworks que ya manejan bucles de eventos.
Requieres debugging avanzado: activar debug y observar el comportamiento interno de asyncio.

**¬øC√≥mo crear y depurar un event loop manual en Python?**
Puedes crear tu propio loop para tener acceso directo a su configuraci√≥n. El flujo es: crear el loop, registrarlo en asyncio, ejecutar hasta completar la tarea y cerrarlo al final para liberar recursos.

import asyncio

async def main():
    # tu l√≥gica as√≠ncrona aqu√≠
    return "ok"

# crear y registrar el loop
loop = asyncio.new_event_loop()
asyncio.set_event_loop(loop)

try:
    # opcional: activar debug del loop
    loop.set_debug(True)

    # ejecutar hasta que la tarea termine
    loop.run_until_complete(main())
finally:
    # importante: cerrar el loop para liberar recursos
    loop.close()
new_event_loop. Crea una instancia de loop y la guarda en una variable, por ejemplo, my_loop.
set_event_loop. Indica a asyncio cu√°l loop debe usar.
run_until_complete. Ejecuta la tarea hasta completarse.
close. Cierra el loop en un bloque finally para no dejar recursos abiertos.

**¬øC√≥mo activar debug y ver logs de asyncio?**
Usa loop.set_debug(True) para habilitar debug en el loop.
Ajusta tu configuraci√≥n de logs a nivel debug para ver mensajes de asyncio, como el ‚Äúselector‚Äù que est√° usando.
Ejecuta tu script y observa el logging de asyncio para entender qu√© tareas se seleccionan y cu√°ndo avanzan.
Consejos pr√°cticos:

En proyectos comunes, asyncio.run es suficiente y recomendable.
El control manual del loop es √∫til para escenarios espec√≠ficos de integraci√≥n y debug profundo.
Mant√©n la limpieza de recursos: siempre cierra el loop.


## CLASE 15: Migraci√≥n de Request s√≠ncrono a HTTPX as√≠ncrono en Python


**¬øQu√© cambia con HTTPX y AsyncIO?**
La ejecuci√≥n deja de ser bloqueante. Antes, cada petici√≥n HTTP esperaba a la anterior. Con AsyncIO y HTTPX se disparan varias solicitudes de forma concurrente, aprovechando mejor el I/O de red y acelerando la obtenci√≥n de art√≠culos. Se preservan los m√©todos s√≠ncronos existentes y se agregan equivalentes as√≠ncronos con prefijo ‚ÄúA‚Äù para distinguirlos y facilitar una migraci√≥n gradual.

Concurrencia real en I/O: m√∫ltiples requests al mismo tiempo.
Prefijo ‚ÄúA‚Äù en m√©todos as√≠ncronos para claridad y consistencia.
Dual approach: s√≠ncrono y as√≠ncrono conviven sin romper usos previos.
Menos tiempo total: respuesta m√°s r√°pida, aprox. 50%.

**¬øC√≥mo se instala HTTPX?**
Se elige HTTPX por su compatibilidad con AsyncIO.
Instalaci√≥n directa: ejecutar en la terminal: V add HTTPX.
Verificaci√≥n: aparece en dependencias de pyproject.toml.

**¬øC√≥mo se define el nuevo protocolo as√≠ncrono?**
En el m√≥dulo source se tiene un protocolo con el m√©todo s√≠ncrono existente (ej.: fetch...).
Se agrega el nuevo m√©todo as√≠ncrono con prefijo ‚ÄúA‚Äù y misma firma y documentaci√≥n.
Se usa async def y se mantiene el tipado para retornar la misma estructura de art√≠culos.

**¬øC√≥mo se implementa en Guardian y News API?**
En guardian.py se crea el m√©todo as√≠ncrono con async def y prefijo ‚ÄúA‚Äù.
Se mueve el logger a la parte superior del archivo para reutilizarlo.
Se importa httpx y se usa un cliente as√≠ncrono con contexto.
import httpx

async def afetch_articles(params):
    # logger definido arriba
    async with httpx.AsyncClient() as client:
        response = await client.get("https://api.guardian...", params=params)
    data = response.json()
    # Adaptar a la estructura de art√≠culos esperada
    return [ ... ]
En News API se repite el refactor: mover logger, importar httpx, crear el m√©todo con prefijo ‚ÄúA‚Äù, usar await y ajustar el mapeo de campos porque los nombres difieren respecto a Guardian.

**¬øC√≥mo se adapta el servicio y la CLI?**
El servicio en core/services agrega un m√©todo as√≠ncrono gemelo del s√≠ncrono (misma responsabilidad, prefijo ‚ÄúA‚Äù). Internamente, obtiene la fuente con el m√©todo actual (sigue siendo s√≠ncrono) y llama al nuevo m√©todo as√≠ncrono de la fuente con await. Se toca el m√≠nimo de funciones para no afectar otras features ni tests.

class NewsService:
    def search_articles(self, ...):
        source = self.get_source(...)
        return source.fetch_articles(...)

    async def a_search_articles(self, ...):
        source = self.get_source(...)
        return await source.afetch_articles(...)
Regla de oro: await solo dentro de funciones async. Por eso, al actualizar el uso desde la CLI, la funci√≥n que invoca el nuevo m√©todo se vuelve async.
Se renombra el main as√≠ncrono y se crea un wrapper s√≠ncrono que ejecuta la corrutina con asyncio.run, manteniendo la compatibilidad del punto de entrada.
async def async_main():
    # await service.a_search_articles(...)
    ...

def main():
    import asyncio
    asyncio.run(async_main())

**¬øC√≥mo mantener compatibilidad hacia atr√°s?**
Compatibilidad: el c√≥digo existente sigue funcionando con m√©todos s√≠ncronos.
Migraci√≥n gradual: m√≥dulo por m√≥dulo, sin pausas grandes.
Flexibilidad: scripts simples usan s√≠ncrono; producci√≥n usa as√≠ncrono.
Testing: los tests no se rompen al conservar los m√©todos previos.

**¬øC√≥mo verificar que HTTPX est√° en uso?**
La validaci√≥n pr√°ctica incluye ejecutar la b√∫squeda y luego activar los logs en modo debug para confirmar que HTTPX realiza los requests.

Ejecutar b√∫squeda: Platinus search con t√©rmino y source News API. Muestra art√≠culos correctamente.
Confirmar HTTPX: PlatzyNews con log level debug para ver los mensajes info/DEBUG de HTTPX indicando requests exitosos.


## CLASE 16: Automatizaci√≥n de tareas con Make y Makefile en proyectos


**¬øQu√© es un task runner y por qu√© usar Make?**
Cuando repetimos comandos como instalar dependencias, correr pruebas o formatear c√≥digo, un task runner evita trabajo manual. Make est√° presente en la mayor√≠a de sistemas Unix y Linux y permite definir tareas comunes y ejecutarlas con un solo comando.

Ahorra tiempo: automatiza tareas repetitivas.
Reduce errores: menos comandos escritos a mano.
Facilita el trabajo en equipo: todos usan los mismos targets.
Comandos cortos: ejecuta con make + nombre de tarea.

**¬øC√≥mo crear un Makefile y ejecutar targets install y run?**
Crea el archivo con eme may√∫scula: Makefile. Define targets como install o run y ejec√∫talos desde la terminal con: make nombre-de-la-tarea. Make ejecuta exactamente los comandos que declares dentro del target.


**¬øC√≥mo definir install para dependencias con @echo?**
Agrega un mensaje y la instalaci√≥n de paquetes. Si no quieres borrar el entorno virtual, elimina esa l√≠nea antes de ejecutar.

install:
    @echo "instalando paquetes"
    vsync
Mensaje informativo con @echo: muestra ‚Äúinstalando paquetes‚Äù.
Instalaci√≥n: el comando vsync se ejecuta autom√°ticamente al correr: make install.

**¬øC√≥mo definir run para instalar y probar Platzi News?**
Este target encadena dos pasos: instalaci√≥n local y ejecuci√≥n de la app con log level de debug.

run:
    vpit install .
    Platzi News log level debug
Instalaci√≥n local: vpit install . construye e instala tu librer√≠a.
Prueba de la aplicaci√≥n: Platzi News con log level debug para validar el comportamiento.
Atajo √∫til: con make run no necesitas recordar comandos largos.

**¬øQu√© particularidades del Makefile debes cuidar?**
Hay detalles esenciales para que todo funcione sin sorpresas. Resp√©talos siempre al escribir y ejecutar tus targets.

Indentaci√≥n con Tab: Make requiere tabuladores, no espacios.
Mensajes con @echo: imprime textos √∫tiles como ‚Äúinstalando paquetes‚Äù.
Ayuda con make help: ideal para mostrar c√≥mo ejecutar los comandos del proyecto.
Ejecuci√≥n directa: make nombre-de-tarea corre lo que definiste en el Makefile.


## CLASE 17: Publicaci√≥n de paquetes Python con UV y TestPyPI

**¬øC√≥mo elegir y configurar el build backend con uv?**
Seleccionar el build backend correcto es clave. Python ofrece varias opciones: SetopToast es flexible pero complejo. Hatchling es moderno, minimalista y veloz. Fleet es extremadamente simple para paquetes puros de Python. Poetry integra backend y gesti√≥n de dependencias. UV funciona con cualquiera que declares en pyproject.toml y recomienda Hatchling por defecto para nuevos proyectos.


**¬øQu√© build backends existen y para qu√© usar Hatchling?**
SetopToast: el m√°s antiguo y tradicional. Muy flexible.
Hatchling: moderno, minimalista y r√°pido. Recomendado por UV.
Fleet: extremadamente simple para Python puro.
Poetry: backend con gestor de dependencias integrado.
Hatchling destaca por su simplicidad y eficiencia. Perfecto para empezar a distribuir sin fricci√≥n.


**¬øC√≥mo declarar build_system en pyproject.toml?**
Define el backend y sus requisitos en la secci√≥n correspondiente. La idea es especificar require y el build backend apuntando a ‚Äú.build‚Äù.

[build_system]
require = ["hatchling"]
build_backend = "hatchling.build"
Guarda y ya podr√°s construir tu paquete con UV.


**¬øC√≥mo construir el paquete y qu√© archivos genera uv?**
Con el proyecto listo y UV configurado, construye los artefactos distribuibles. El comando central es simple y muestra el output con los archivos resultantes.


**¬øQu√© hace el comando uv build?**
Ejecuta el proceso de empaquetado del proyecto.
Genera dos archivos listos para publicar: el sdist y el wheel.
uv build

**¬øQu√© significan sdist tar.gz y wheel whl?**
tar.gz: el source distribution (sdist). C√≥digo fuente empaquetado.
whl: el wheel. Distribuci√≥n binaria lista para instalar.
Estos son los dos archivos que se suben al manejador de paquetes.


**¬øC√≥mo publicar en TestPyPI con seguridad y tokens?**
Antes de publicar en PyPI, usa su entorno de pruebas: test.pypi. As√≠ validas que el sistema de build y publicaci√≥n funciona sin afectar el √≠ndice principal.


**¬øC√≥mo crear cuenta y activar 2FA en TestPyPI?**
Reg√≠strate y verifica tu correo con el enlace enviado.
Activa two factor authentication: genera y guarda c√≥digos de recuperaci√≥n.
Escanea el QR en tu app de autenticaci√≥n y valida el c√≥digo.
Con esto, tu cuenta queda lista y protegida para publicar.


**¬øC√≥mo generar y usar un token con uv publish?**
Crea un token con alcance al proyecto que vas a publicar.
En tu Makefile, define un comando de publicaci√≥n usando el token y el √≠ndice de pruebas.
publish:
    uv publish \
      --index test-pypi \
      --username __token \
      --password $(TOKEN)
Ejecuta el objetivo de Make:
make publish
Si aparece un error, probablemente falta registrar el √≠ndice en pyproject.toml.


**¬øC√≥mo registrar el index en tool.uv.index?**
Declara la lista de √≠ndices que usar√°s en UV con nombre, URL, publish URL y explicit true.

[tool.uv.index."test-pypi"]
url = "test.pypi.org"
publish-url = "test.pypi.org"
explicit = true
Ahora vuelve a publicar con UV y revisa el output. Deber√≠as ver que sube los artefactos, incluso menciona que subi√≥ dos versiones.


**¬øC√≥mo verificar, buscar e instalar el paquete?**
Ve a test.pypi y busca ‚ÄúPlatsy News‚Äù. Deber√≠as ver la p√°gina p√∫blica con descripci√≥n y README.
Instala con pip usando la URL del √≠ndice de prueba y el nombre del paquete.
pip install -i <URL> Platsy News
Con esto, ya puedes instalar, configurar tu entorno y empezar a usar la librer√≠a. Felicidades: lograste publicar tu primer paquete en el manejador de paquetes principal de Python. Insp√≠rate, crea librer√≠as open source, y comparte tu trabajo con la comunidad. Como referencia, Luis Mart√≠nez menciona su experiencia con Django, FastAPI y arquitecturas en la nube, e invita a pensar como desarrollador avanzado: c√≥digo limpio, ideas que escalan y despliegue a producci√≥n.
