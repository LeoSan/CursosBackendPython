# Curso de Estad√≠stica Computacional con PythonüöÄ

> Domina la estad√≠stica computacional usando Python para analizar datos, realizar simulaciones y calcular probabilidades. Aprende a aplicar t√©cnicas de inferencia estad√≠stica y a desarrollar simulaciones de Monte Carlo.

| Detalle | Informaci√≥n |
| :--- | :--- |
| **Publicado el** | 24 FEBRERO 2025 |
| **Profesor** | DAVID AROESTI  |
| **Fecha de Inicio** | 11/12/2025  |
| **Fecha de Fin** | 31/12/2025  |
| **Enlace** | https://platzi.com/cursos/programacion-estocastica/ |


---
<div align="center">
  <img src="image-2.png" alt="Global Certificate" width="50%" />
</div>


| Curso | Certificado |
| :--- | :---: |
| Curso de Estad√≠stica Computacional con Python | [Ver PDF](https://github.com/LeoSan/CursosBackendPython/blob/main/02_DesarrolloBackendPythonDjango_2025_Avanzado\05_CursoEstadisticaComputacionalPython\2025_CursoEstadisticaComputacionalPython_PLATZI.pdf) |

--- 

## CLASE 01: INTRODUCCI√ìN 

**Objetivos**
‚óè Aprender cu√°ndo utilizar Programaci√≥n
Din√°mica y sus beneficios
‚óè Entender la diferencia entre programas
deterministas y estoc√°sticos
‚óè Aprender a utilizar Programaci√≥n Estoc√°stica
‚óè Aprender a crear simulaciones computacionales
v√°lidas

## CLASE 02: Programaci√≥n Din√°mica: Optimizaci√≥n de Problemas con Memorizaci√≥n

> [El nombre] Programaci√≥n Din√°mica se escogi√≥ para esconder a patrocinadores gubernamentales el hecho que en realidad estaba haciendo Matem√°ticas. La frase Programaci√≥n Din√°mica es algo que ning√∫n congresista puede oponerse. **Richard Bellman**


**PUNTOS CLAVES**

> Programaci√≥n Din√°mica
‚óè Subestructura √ìptima. Una soluci√≥n global
√≥ptima se puede encontrar al combinar
soluciones √≥ptimas de subproblemas locales.
‚óè Problemas empalmados. Una soluci√≥n √≥ptima
que involucra resolver el mismo problema en
varias ocasiones.


> Memoization
‚óè La Memorizaci√≥n es una t√©cnica para guardar
c√≥mputos previos y evitar realizarlos
nuevamente.
‚óè Normalmente se utiliza un diccionario, donde las
consultas se pueden hacer en O(1).
‚óè Intercambia tiempo por espacio.


**¬øQu√© es la programaci√≥n din√°mica?**

La programaci√≥n din√°mica es un concepto indispensable en el mundo de las ciencias de la computaci√≥n. A pesar de su nombre, el cual no refleja su verdadera esencia, es una t√©cnica poderosa para optimizar ciertos tipos de problemas. La historia de su origen es peculiar: Richard Bellman acu√±√≥ este t√©rmino en la d√©cada de 1950 para garantizar el financiamiento de sus investigaciones matem√°ticas, utilizando un nombre que sonara impresionante pero que, curiosamente, no est√° relacionado con el dinamismo. Sin embargo, su aplicaci√≥n ha demostrado ser fundamental en la inform√°tica.

**¬øC√≥mo funciona la programaci√≥n din√°mica?**

La programaci√≥n din√°mica se centra en problemas con una "subestructura √≥ptima". Esto significa que la soluci√≥n global √≥ptima se puede alcanzar dividiendo el problema en partes m√°s peque√±as, resolviendo cada una de manera √≥ptima antes de combinarlas para obtener la soluci√≥n total. Ejemplos de su aplicaci√≥n incluyen:

- El problema del morral (Knapsack problem): Aqu√≠ se buscan soluciones √≥ptimas en problemas cada vez m√°s peque√±os.

- La secuencia de Fibonacci: La soluci√≥n se genera dividiendo el problema en partes m√°s reducidas y encontrando soluciones para cada segmento menor.

- Las soluciones a estos problemas m√°s peque√±os se combinan para hallar una soluci√≥n a la totalidad del problema.

**¬øQu√© es la memorizaci√≥n en programaci√≥n din√°mica?**

La memorizaci√≥n es crucial para hacer eficiente la programaci√≥n din√°mica. Se utiliza para evitar c√°lculos innecesarios al almacenar resultados de computaciones previas en una estructura de datos, como un diccionario, que nos permite acceder r√°pidamente a estos datos almacenados. He aqu√≠ algunos puntos clave sobre la memorizaci√≥n:

Optimizaci√≥n de tiempo: Al guardar los resultados en la memoria del sistema, se disminuyen significativamente los tiempos de c√≥mputo.

Intercambio de tiempo por espacio: Este concepto es esencial en ciencias de la computaci√≥n, donde al aumentar el uso del espacio de memoria, se reduce el tiempo necesario para la soluci√≥n del problema.

Utilizando la memorizaci√≥n, se logra que los programas no repitan c√°lculos ya realizados, lo que resulta en la ejecuci√≥n de programas mucho m√°s r√°pidos y eficientes.

**¬øCu√°les son las aplicaciones pr√°cticas de la programaci√≥n din√°mica?**
La programaci√≥n din√°mica se aplica a una variedad de problemas, haciendo de su comprensi√≥n algo esencial para cualquier estudiante de inform√°tica. Con ejemplos amplios en algoritmos y optimizaci√≥n, contin√∫a siendo un √°rea f√©rtil para el aprendizaje y la aplicaci√≥n:

- Ordenaci√≥n y b√∫squeda: Se utilizan t√©cnicas para estructurar datos ordenadamente y b√∫squedas eficientes.

- Resoluci√≥n de problemas matem√°ticos complejos: Desde la secuencia de Fibonacci hasta problemas de combinatoria, la programaci√≥n din√°mica ofrece formas eficientes de llegar a soluciones.

- Optimizaci√≥n de recursos: Eficiente en tareas de asignaci√≥n de recursos y planificaci√≥n.

- Aprovechar las t√©cnicas de programaci√≥n din√°mica no solo refuerza la comprensi√≥n te√≥rica, sino que potencia la capacidad de resolver problemas complejos de manera sistem√°tica y optimizada.

**En conclusi√≥n, la programaci√≥n din√°mica y la memorizaci√≥n son conceptos que, aunque quiz√°s intrincados en su origen, se revelan como herramientas esenciales en la caja de herramientas de cualquier ingeniero en inform√°tica. Su dominio abre puertas a la optimizaci√≥n de programas y algoritmos, culminando en soluciones eficientes e innovadoras. Contin√∫a explorando estos conceptos para mejorar tu comprensi√≥n del fascinante mundo de las ciencias de la computaci√≥n.**


![alt text](image.png)

## CLASE 03:  Optimizaci√≥n de Algoritmos con Programaci√≥n Din√°mica en Python


**¬øQu√© es la Programaci√≥n Din√°mica?**
La programaci√≥n din√°mica es una metodolog√≠a de optimizaci√≥n que ahorra tiempo al intercambiar espacio. Utiliza la memorizaci√≥n para evitar c√°lculos repetidos al guardar los resultados de subproblemas que se pueden reutilizar. Esto es esencial en problemas donde hay muchas subestructuras comunes, como es el caso de la secuencia de Fibonacci.

**¬øC√≥mo se implementa la secuencia de Fibonacci de forma recursiva?**
A pesar de ser sencilla de implementar, la soluci√≥n recursiva a la secuencia de Fibonacci es ineficiente debido al c√°lculo repetido de los mismos subproblemas. El algoritmo recursivo es el siguiente:

```PYTHON

import sys
sys.setrecursionlimit(10002)

def fibonacci_dinamico(n, memo = {}):
    if n == 0 or n == 1:
        return 1
    if n in memo:
        return memo[n]
    memo[n] = fibonacci_dinamico(n-1, memo) + fibonacci_dinamico(n-2, memo)
    return memo[n]

if __name__ == '__main__':
    n = int(input("Escoge un n√∫mero: "))
    print(f"Fibonacci de {n} es {fibonacci_dinamico(n)}")    

```

> Recuerda programaci√≥n algoritmica depende de la complegidad algoritmica ya que hay que saber a nivel de base que tipo de complejidad tiene el algoritmo.


**Dejo base de la complejidad algoritmica Complejidad Algor√≠tmica (Big O Notation)**
![alt text](image-1.png)

"""
üü¢ Zona Verde: P (Tiempo Polin√≥mico - "Eficiente")
Estos son los algoritmos que las computadoras pueden resolver en un tiempo razonable, incluso con muchos datos.

- $O(1)$ - Constante: El mejor de todos. No importa si tienes 10 datos o 1 mill√≥n, toma el mismo tiempo.
Ejemplo: Acceder a un valor en un diccionario de Python o un array por su √≠ndice.

- $O(\log n)$ - Logar√≠tmica: Muy r√°pido. El tiempo crece muy lentamente comparado con los datos.
Ejemplo: B√∫squeda binaria (buscar una palabra en un diccionario f√≠sico abriendo por la mitad).

- $O(n)$ - Lineal: El tiempo crece proporcionalmente a los datos. Si duplicas los datos, duplicas el tiempo.
Ejemplo: Recorrer una lista con un bucle for simple.

- $O(n \log n)$: Un poco m√°s lento que lineal, pero muy eficiente. Es el est√°ndar para ordenar cosas.
Ejemplo: Los algoritmos de ordenamiento eficientes como Merge Sort o Quick Sort (lo que usa .sort() en Python).

- $O(n^2)$ - Cuadr√°tica: El tiempo crece al cuadrado. Com√∫n en algoritmos "ingenuos".
Ejemplo: Un bucle for dentro de otro (bucles anidados). Com√∫n en ordenamiento burbuja.

- $O(n^3)$ y $O(n^k)$: C√∫bica o Polin√≥mica general. Bucles triples, cu√°druples, etc. Sigue siendo "resoluble" (est√° en P), pero se vuelve lento r√°pido.


üî¥ Zona Roja: NP (No Polin√≥mico* / Intratable)
- Nota t√©cnica: Aunque la imagen dice "NP", en este contexto visual se refiere a algoritmos que "No son Polin√≥micos" o que son Exponenciales/Factoriales. 
- Estos algoritmos son tan lentos que se vuelven in√∫tiles si $n$ crece un poco (por ejemplo, si $n=100$, el programa podr√≠a tardar siglos).

- $O(2^n)$ - Exponencial: Por cada dato nuevo, el tiempo se duplica. Esto explota rapid√≠simo.
Ejemplo: Fibonacci Recursivo sin memoria (el que viste en tu README antes de optimizar). Calcular Fibonacci de 50 as√≠ podr√≠a tardar a√±os.

- $O(n!)$ - Factorial: La peor pesadilla. Crece monstruosamente r√°pido.
Ejemplo: El problema del viajero (probar todas las rutas posibles entre ciudades). Si tienes 20 ciudades, es casi imposible de calcular a fuerza bruta.

""" 
## CLASE 04: Simulaciones con Caminos Aleatorios en Programaci√≥n

**¬øC√≥mo explicaron Einstein y el movimiento browniano esta teor√≠a?**

Uno de los ejemplos m√°s sorprendentes y fundamentales del uso de aleatoriedad es el movimiento browniano. En el siglo XIX, la mejora en los microscopios permiti√≥ observar comportamientos inesperados en part√≠culas microsc√≥picas que no pod√≠an ser explicados con el conocimiento de la √©poca. Fue Albert Einstein el que explic√≥ este fen√≥meno siendo un pionero en el uso de la aleatoriedad para entender c√≥mo las mol√©culas de agua, al moverse aleatoriamente, impactan part√≠culas de polen, generando lo que se conoce como movimiento browniano. Este descubrimiento le vali√≥ el Premio Nobel, no por su teor√≠a de la relatividad, sino por este entendimiento profundo del comportamiento aleatorio a nivel molecular.

**¬øQu√© aplicaciones tienen los caminos aleatorios en las simulaciones?**
Los caminos aleatorios son la clave para crear simulaciones avanzadas y precisas en m√∫ltiples campos:

Simulaci√≥n de part√≠culas: Las simulaciones como la del humo, utilizan caminos aleatorios para modelar el comportamiento de millones de part√≠culas. Mediante la definici√≥n de un comportamiento general, las part√≠culas se mueven de manera aleatoria, reproduciendo el movimiento ca√≥tico del humo.

Uni√≥n de galaxias: A nivel macro, estas simulaciones ayudan a entender fen√≥menos astron√≥micos. Por ejemplo, la probable fusi√≥n de la galaxia V√≠a L√°ctea con Andr√≥meda es modelada usando caminos aleatorios, permitiendo prever el comportamiento de las estrellas y la gravedad involucradas.

Mercados financieros: En el √°mbito econ√≥mico, se utilizan para simular el comportamiento del mercado de valores, ayudando a predecir c√≥mo las acciones pueden subir o bajar en el tiempo.

**¬øQu√© relaci√≥n tienen con el arte y la tecnolog√≠a?**
La aleatoriedad no se limita al √°mbito cient√≠fico, tambi√©n se extiende a la creaci√≥n art√≠stica:

Escultura de nube cu√°ntica: Un ejemplo fascinante es el Quantum Cloud en Londres. Esta atracci√≥n tur√≠stica utiliza caminos aleatorios computacionales para posicionar los elementos de la escultura, creando as√≠ una estructura singular que desaf√≠a las nociones tradicionales del arte.

```PYTHON


```
![alt text](image-3.png)

## CLASE 05: Camino Aleatorio en Programaci√≥n Orientada a Objetos

**¬øQu√© es la programaci√≥n din√°mica y estoc√°stica?**

La programaci√≥n din√°mica y estoc√°stica es una t√©cnica que se utiliza en el dise√±o de algoritmos para resolver problemas de optimizaci√≥n que se caracterizan por la incertidumbre y la necesidad de tomar decisiones secuenciales. Esta t√©cnica es fundamental en la resoluci√≥n de problemas en diversos campos como la ingenier√≠a, la econom√≠a o las ciencias de la computaci√≥n.

En este contexto, la profesora introduce un concepto interesante: el camino de borrachos. Descubramos c√≥mo este concepto se materializa en un algoritmo de programaci√≥n orientada a objetos.

**¬øC√≥mo se implementa el camino de borrachos?**
El algoritmo del camino de borrachos se deriva de un problema que simula el movimiento aleatorio de un borracho que camina en un campo. Para entender c√≥mo se desarrolla este concepto en programaci√≥n, dividimos el problema en tres clases fundamentales:

Borracho: Un objeto que representa a una persona que se mueve de manera aleatoria.
Campo: Un objeto que define el entorno o mapa en el cual el borracho se mueve.
Coordenada: Un concepto abstracto que sirve para definir la posici√≥n dentro del campo.

**¬øC√≥mo se representa a trav√©s de programaci√≥n orientada a objetos?**
La programaci√≥n orientada a objetos permite modelar el mundo real creando clases y objetos. En el caso del camino de borrachos, las clases mencionadas se configuran de la siguiente manera:

Borracho: Puede imaginarse como un individuo que se mueve dentro de las coordenadas de un campo. Adem√°s, se pueden extender sus caracter√≠sticas para definir comportamientos espec√≠ficos, como un "borracho tradicional" que se mueve aleatoriamente a uno de los lados cardinales.

Campo: Funciona como un mapa y contiene las disposiciones de las coordenadas, permitiendo que el borracho se desplace dentro de √©l.

Coordenada: Es como un marcador que se√±ala la posici√≥n actual del borracho dentro del campo, similar a un pin en Google Maps.

**¬øC√≥mo se implementa el movimiento del borracho?**
El borracho se mueve aleatoriamente dentro del campo a trav√©s de movimientos en los ejes X e Y. Estos movimientos pueden ser:

Hacia la izquierda: decremento en el eje X.
Hacia la derecha: incremento en el eje X.
Hacia arriba: incremento en el eje Y.
Hacia abajo: decremento en el eje Y.
Aqu√≠ les presento un fragmento del c√≥digo en Python:

class Borracho:
    def __init__(self):
        pass

    def mover(self):
        return random.choice([(1,0), (0,1), (-1,0), (0,-1)])

class Campo:
    def __init__(self):
        pass
¬øC√≥mo se integran estas clases en la funci√≥n principal?
Para concretar el comportamiento del borracho y sus desplazamientos, es necesario definir una funci√≥n principal o main, un punto de entrada com√∫n en la mayor√≠a de los lenguajes de programaci√≥n:

if __name__ == '__main__':
    # Implementaci√≥n del movimiento del borracho
    # C√≥digo para crear instancias de las clases e interactuar con ellas
El main se encarga de gestionar el flujo del programa: crear objetos, iniciar movimientos y registrar resultados. Se pueden implementar simulaciones para ver c√≥mo var√≠a la posici√≥n del borracho tras un n√∫mero determinado de pasos.

¬øC√≥mo se eval√∫an los resultados de las simulaciones?
En programaci√≥n estoc√°stica, ejecutar una simulaci√≥n una sola vez no proporciona suficiente informaci√≥n debido a su componente aleatorio. Por ello, es necesario realizar m√∫ltiples simulaciones para obtener resultados promedio m√°s fiables.

Simulaciones M√∫ltiples: Es importante ejecutar varias simulaciones (por ejemplo, 100) para cada n√∫mero de pasos definido, obteniendo as√≠ la media de las distancias recorridas.

Distancias M√°xima y M√≠nima: Evaluar la distancia m√°xima y m√≠nima alcanzada por el borracho en las distintas simulaciones proporciona insights sobre el comportamiento y alcance de los movimientos.


```PYTHON
import random

class Borracho:

    def __init__(self):
        self.posicion = [0,0]


    def camino_borrachos(self, pasos=0):
        direccion = random.choice(["derecha","izquierda","arriba","abajo"])
        for i in range(pasos):
            direccion = random.choice(["derecha", "izquierda", "arriba", "abajo"])
            if direccion == "izquierda":
                self.posicion[0] -= 1
            elif direccion == "derecha":
                self.posicion[0] += 1
            elif direccion == "arriba":
                self.posicion[1] += 1
            elif direccion == "abajo":
                self.posicion[1] -= 1
            else:
                return None
        return self.posicion

if __name__ == "__main__":
    borrachin = Borracho()
    direccion_final = borrachin.camino_borrachos(pasos=500)
    print(direccion_final)
    distancia_final = (direccion_final[0]**2+direccion_final[1]**2)**0.5
    print("La distancia final es: ",distancia_final)

```

![alt text](image-2.png)

## CLASE 06: Algoritmo de Caminata Aleatoria en Python: Clase Borracho

¬øQu√© es un camino aleatorio?
Un camino aleatorio comienza en un punto de origen y puede moverse en varias direcciones: arriba, abajo, izquierda, o derecha, con una probabilidad igual del 25% para cada direcci√≥n. Este proceso se repite en cada paso, llevando a infinitas posibilidades de recorrer diferentes trayectorias. Algunos aspectos interesantes de un camino aleatorio incluyen:

Puede ser extendido a m√∫ltiples dimensiones, no solo en 2D, sino tambi√©n en 3D, 5D, etc.
Se pueden asignar probabilidades diferentes para cada movimiento.
La distancia recorrida se calcula f√°cilmente mediante el teorema de Pit√°goras.
¬øC√≥mo podemos representar un borracho?
En el contexto del camino de borrachos, un borracho es una entidad que se mueve al azar en un plano. Implementamos la clase Borracho para abstraer el comportamiento de esta entidad.

class Borracho:
    def __init__(self, nombre):
        self.nombre = nombre
De esta manera, al extender Borracho, podemos crear subclases que modelen diferentes tipos de trayectorias y comportamientos. Un ejemplo de subclase es el BorrachoTradicional, quien se mueve aleatoriamente entre cuatro opciones: arriba, abajo, izquierda y derecha.

¬øC√≥mo defino los movimientos del borracho?
Usamos la clase BorrachoTradicional para implementar esta l√≥gica con la ayuda de la librer√≠a random de Python.

import random

class BorrachoTradicional(Borracho):
    def __init__(self, nombre):
        super().__init__(nombre)

    def camina(self):
        return random.choice([(0, 1), (0, -1), (1, 0), (-1, 0)])
Aqu√≠ random.choice se utiliza para seleccionar aleatoriamente una de las direcciones posibles, reflejando nuestro modelo de movimientos equiprobables.

¬øC√≥mo manejamos las coordenadas y calculamos distancias?
Para gestionar la posici√≥n en el plano, creamos la clase Coordenada. Esta clase se encarga de las posiciones y desplazamientos del borracho.

import math

class Coordenada:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def mover(self, delta_x, delta_y):
        return Coordenada(self.x + delta_x, self.y + delta_y)

    def distancia(self, otra_coordenada):
        delta_x = self.x - otra_coordenada.x
        delta_y = self.y - otra_coordenada.y
        return math.sqrt(delta_x**2 + delta_y**2)
Aqu√≠, utilizamos el teorema de Pit√°goras para calcular la distancia entre dos puntos.

¬øC√≥mo se representa el campo?
El campo es el espacio que contiene a los borrachos. Implementamos esto a trav√©s de la clase Campo, la cual permitir√° a√±adir, mover, y consultar las coordenadas de nuestros "borrachos".

class Campo:
    def __init__(self):
        self.coordenadas_de_borrachos = {}

    def a√±adir_borracho(self, borracho, coordenada):
        self.coordenadas_de_borrachos[borracho] = coordenada

    def mover_borracho(self, borracho):
        delta_x, delta_y = borracho.camina()
        coordenada_actual = self.coordenadas_de_borrachos[borracho]
        nueva_coordenada = coordenada_actual.mover(delta_x, delta_y)
        self.coordenadas_de_borrachos[borracho] = nueva_coordenada

    def obtener_coordenada(self, borracho):
        return self.coordenadas_de_borrachos[borracho]
Con esto, ahora tenemos el framework necesario para implementar simulaciones complejas de caminos aleatorios. Estas clases nos ofrecen la flexibilidad para modelar diferentes escenarios de simulaci√≥n.
```PYTHON


```


## CLASE 07: Simulaci√≥n de Caminata Aleatoria con Python

¬øC√≥mo se configura el entorno para simular una caminata de borrachos?
Primero, es esencial importar las clases que hemos creado para simular nuestra caminata. Estas son BorachoTradicional, Campo, y Coordenada. Reiterar la distinci√≥n entre "Campo" (el m√≥dulo) y "Campo" (la clase) es fundamental.

El siguiente paso es establecer un entorno para ejecutar el programa mediante if __name__ == "__main__": asegurando que nuestro c√≥digo se ejecute cuando sea llamado desde la terminal. Luego definimos las distancias de las caminatas y la cantidad de intentos de simulaci√≥n, que ser√°n 10, 100, 1000, y 10000 pasos en 100 intentos cada una. Estos m√∫ltiplos permiten medir m√°s precisamente la media de los resultados logrados.

¬øC√≥mo definimos la funci√≥n main?
La funci√≥n main es vital ya que coordina la simulaci√≥n. Recibe tres par√°metros:

distancias_de_caminata: lista de enteros indicando la cantidad de pasos por simulaci√≥n.
num_intentos: n√∫mero de veces que cada simulaci√≥n se debe ejecutar para obtener una media precisa.
tipo_de_borracho: la clase del borracho que se utilizar√°, como BorachoTradicional.
C√≥digo de ejemplo para la funci√≥n main
def main(distancias_de_caminata, num_intentos, tipo_de_borracho):
    for dist in distancias_de_caminata:
        # Simula la caminata para cada distancia y n√∫mero de intentos
        distancias = simular_caminata(dist, num_intentos, tipo_de_borracho)
        # Genera estad√≠sticas de las simulaciones
        distancia_media = round(sum(distancias) / len(distancias), 3)
        distancia_maxima = max(distancias)
        distancia_minima = min(distancias)
        # Imprime resultados
        print(f'{tipo_de_borracho.__name__} tuvo una caminata aleatoria de {dist} pasos')
        print(f'Distancia media: {distancia_media}')
        print(f'Distancia m√°xima: {distancia_maxima}')
        print(f'Distancia m√≠nima: {distancia_minima}\n')
¬øC√≥mo implementamos la simulaci√≥n de la caminata?
La funci√≥n simular_caminata organiza c√≥mo un borracho se desplazar√° paso a paso desde una coordenada inicial (0, 0).

Inicializaci√≥n: Crea una instancia del tipo de borracho y establece el punto de inicio en (0, 0).
Iteraci√≥n: Por cada intento, se crea un nuevo campo y se a√±ade el borracho en la coordenada inicial.
Movimiento: Utiliza la funci√≥n caminata para mover el borracho seg√∫n el n√∫mero de pasos definidos y calcula la distancia.
Ejemplo de C√≥digo para simular_caminata
def simular_caminata(pasos, num_intentos, tipo_de_borracho):
    distancias = []
    for _ in range(num_intentos):
        campo = Campo()
        borracho = tipo_de_borracho()
        origen = Coordenada(0, 0)
        campo.anadir_borracho(borracho, origen)
        simulacion_distancia = caminata(campo, borracho, pasos)
        distancias.append(round(simulacion_distancia, 1))
    return distancias
¬øC√≥mo implementamos el movimiento del borracho?
La funci√≥n caminata simula el movimiento paso a paso:

Inicio: La coordenada inicial es (0, 0).
Iteraci√≥n: Por cada paso, se llama a la funci√≥n mover_borracho del campo, que mueve al borracho y actualiza su posici√≥n.
Resultado: Calcula la distancia final entre la posici√≥n inicial y la alcanzada tras todos los pasos.
C√≥digo de Ejemplo para caminata
def caminata(campo, borracho, pasos):
    inicio = campo.obtener_coordenada(borracho)
    for _ in range(pasos):
        campo.mover_borracho(borracho)
    return inicio.distancia(campo.obtener_coordenada(borracho))

```PYTHON


```

## CLASE 08: Visualizaci√≥n de Caminatas Aleatorias con Python y Bokeh


¬øC√≥mo ejecutar el c√≥digo y corregir errores comunes?
Es frecuente encontrarse con errores al ejecutar c√≥digo, pero cada uno es una oportunidad para aprender. Para ejecutar un script de Python, abre una terminal, navega a la carpeta del proyecto y usa el comando python script.py. Si aparece un error, no te preocupes. En este caso, los errores encontrados fueron:

Nombre no definido: En el c√≥digo se intent√≥ utilizar la funci√≥n rango, cuando deber√≠a ser range(). Corrige el nombre y vuelve a intentarlo.

N√∫mero incorrecto de argumentos: Al definir m√©todos dentro de una clase en Python, siempre se debe incluir self como primer par√°metro. Corrige esto para evitar errores de argumentos.

Estos pasos b√°sicos te ayudar√°n a ejecutar tu c√≥digo correctamente y aprender qu√© mejorar cuando se presenten fallos.

¬øC√≥mo interpretar los resultados de la simulaci√≥n de caminos aleatorios?
Al ejecutar la simulaci√≥n de caminos aleatorios, obtienes resultados como la media, distancia m√°xima y m√≠nima de pasos. En este ejemplo:

10 pasos: Media de distancia fue 3, m√°xima 7, m√≠nima 0. El borracho regres√≥ al origen.
100 pasos: Alejamiento gradual, pero regresos frecuentes al origen.
1000 pasos: Mayor alejamiento del origen.
10,000 pasos: Incremento en la distancia m√°xima y m√≠nima.
Estos resultados muestran c√≥mo, aun con eventos aleatorios incorporados, la simulaci√≥n se comporta de manera consistente con lo esperado estad√≠sticamente. Cada ejecuci√≥n te dar√° resultados ligeramente diferentes debido a su naturaleza estoc√°stica.

¬øC√≥mo graficar los datos con la librer√≠a Bokeh?
Visualizar los datos puede brindarte una mejor comprensi√≥n de los resultados. Para esto, usamos la librer√≠a Bokeh, recomendada por su facilidad de uso:

Configura un entorno virtual para no instalar la librer√≠a de manera global:

python -m venv venv
source venv/bin/activate # Linux/MacOS
.\venv\Scripts\activate  # Windows
Instala Bokeh:

pip install bokeh
Importa y utiliza Bokeh en el c√≥digo:

from bokeh.plotting import figure, show

def graficar(x, y):
    plot = figure(title="Camino aleatorio", x_axis_label='Pasos', y_axis_label='Distancia')
    plot.line(x, y, legend_label="Distancia Media")
    show(plot)
Ejecuta tu c√≥digo para ver la gr√°fica despu√©s de haber a√±adido los pasos para los ejes.

¬øQu√© reto puedes intentar para continuar el aprendizaje?
Como ejercicio pr√°ctico, te animamos a modificar la clase del borracho o crear una nueva implementaci√≥n. Var√≠a el comportamiento, como el incremento en los pasos hacia cualquier direcci√≥n, y observa c√≥mo afectas la simulaci√≥n.

Cambia los pasos a m√°s frecuentes en una direcci√≥n.
Prueba m√∫ltiples direcciones con diferentes probabilidades.
Compara el comportamiento de diferentes "borrachos" entre s√≠.

```PYTHON


```

## CLASE 09: Programaci√≥n Estoc√°stica: Aplicaciones y Ejemplos Pr√°cticos

Soluciones deterministicas son usadas

Cuando se conoce el sistema a profundidad.
Soluciones estocasticas son usadas

Cuando la soluci√≥n deterministica requiere alto procesamiento computacional;
Cuando todas las variables del sistema no est√°n bien descritas.


Estoc√°stico: Aleatorio, depende del azar.

Determinista: No hay incertidumbre. (Por lo tanto no posee aleatoriedad)

Qu√© es la programaci√≥n estoc√°stica

Teniendo claro los significados de ‚Äúestoc√°stico‚Äù y ‚Äúdeterminista‚Äù, podemos pasarnos al siguiente t√©rmino.

Programaci√≥n determinista, es aquella que para un mismo input siempre se obtiene el mismo output, sin importar el n√∫mero de veces que el programa sea ejecutado. Este tipo de programaci√≥n es la m√°s com√∫n y es sumamente importante para para resoluci√≥n de problemas, sin embargo no es suficiente, ya que existe problemas que no pueden ser resueltos de forma determinista.

Para ello entramos a la programaci√≥n estoc√°stica, la cual al contener elementos de aleatoriedad e incertidumbre, es capaz de resolver problemas por medio de simulaci√≥n y an√°lisis de probabilidad.

Algunos ejemplos de programaci√≥n estoc√°stica son:

Sincronizaci√≥n de sem√°foros en una ciudad dependiendo de los datos estad√≠sticos de tr√°fico.
Optimizaci√≥n de log√≠stica y cadena de suministros.
Toma de decisiones de marketing.
Planificaci√≥n de la distribuci√≥n de recursos de un proyecto.

```PYTHON


```


## CLASE 10:  C√°lculo de Probabilidades y Simulaci√≥n de Montecarlo

¬øQu√© es la probabilidad y c√≥mo se mide?
La probabilidad es una herramienta crucial para entender y predecir eventos futuros en un mundo lleno de incertidumbre. Se mide en una escala de cero a uno, donde cero indica que un evento no suceder√° y uno que suceder√° con absoluta certeza. Por ejemplo, las probabilidades de fen√≥menos improbables, como ver unicornios voladores, son te√≥ricamente cero. En contraste, la probabilidad de eventos cotidianos, como que ma√±ana amanezca, es pr√°cticamente uno. Este concepto nos ayuda a visualizar y medir las posibilidades de diferentes escenarios en la vida real.

¬øC√≥mo calcular eventos posibles en un universo de posibilidades?
Cuando hablamos de probabilidad, nos referimos a la fracci√≥n de eventos que ocurren dentro de un conjunto de eventos posibles. Para calcular todos estos eventos, utilizamos m√©todos como la enumeraci√≥n exhaustiva. Esta t√©cnica, tambi√©n conocida como "Brute Force", nos permite listar todas las combinaciones posibles de eventos y as√≠ calcular sus probabilidades.

A menudo se requiere contar los eventos posibles antes de determinar la probabilidad de uno espec√≠fico. Comprender esta t√©cnica nos ayuda a descomponer problemas complejos en partes m√°s manejables y a visualizar c√≥mo pueden desarrollarse diferentes escenarios.

¬øCu√°les son las leyes fundamentales de la probabilidad?
Existen dos leyes fundamentales en la probabilidad, aplicables en diferentes situaciones:

Ley del complemento: La probabilidad de que un evento ocurra sumada a la probabilidad de que no ocurra siempre es igual a uno. Matem√°ticamente se expresa como (Prob(A) + Prob(\neg A) = 1). Un ejemplo es un dado de seis caras: si la probabilidad de sacar un 1 es (1/6), entonces la probabilidad de no sacar un 1 es (5/6).

Leyes multiplicativa y aditiva:

La ley multiplicativa indica la probabilidad de que dos eventos independientes ocurran simult√°neamente. La probabilidad conjunta es el producto de sus probabilidades individuales.
La ley aditiva se aplica para determinar la probabilidad de que ocurra al menos uno de varios eventos mutuamente excluyentes sumando sus probabilidades individuales.

```PYTHON


```

## CLASE 11: Simulaciones de Probabilidades con Dados en Python
¬øC√≥mo calcular probabilidades mediante simulaci√≥n?
La simulaci√≥n nos ofrece una poderosa herramienta para calcular probabilidades de eventos complejos de manera intuitiva. A diferencia de los m√©todos anal√≠ticos, que pueden ser complejos y laboriosos, las simulaciones son m√°s accesibles y permiten experimentar con distintos par√°metros de manera sencilla. En este enfoque, utilizaremos las simulaciones para ejecutar experimentos sobre el lanzamiento de dados, explorando diversas variaciones para obtener resultados probabil√≠sticos.

¬øC√≥mo implementamos la simulaci√≥n en Python?
Para realizar la simulaci√≥n en Python, primero debemos configurar nuestro entorno y entender los componentes b√°sicos del c√≥digo. Utilizamos la biblioteca random para generar lanzamientos de dados aleatorios. A continuaci√≥n, mostramos el c√≥digo esencial:

import random

def main(numero_de_tiros, numero_de_intentos):
    tiros = []
    for _ in range(numero_de_intentos):
        secuencia = tirar_dado(numero_de_tiros)
        tiros.append(secuencia)
    
    tiros_con_uno = sum(1 for tiro in tiros if 1 in tiro)
    probabilidad = tiros_con_uno / numero_de_intentos
    print(f'La probabilidad de obtener al menos un uno en {numero_de_tiros} tiros es: {probabilidad}')

def tirar_dado(numero_de_tiros):
    secuencia = []
    for _ in range(numero_de_tiros):
        tiro = random.choice([1, 2, 3, 4, 5, 6])
        secuencia.append(tiro)
    return secuencia

if __name__ == '__main__':
    numero_de_tiros = int(input('Cu√°ntos tiros del dado: '))
    numero_de_intentos = int(input('Cu√°ntas veces correras la simulaci√≥n: '))
    main(numero_de_tiros, numero_de_intentos)
¬øQu√© son las variables clave en la simulaci√≥n?
N√∫mero de tiros: Determina cu√°ntas veces lanzamos el dado en cada intento.
N√∫mero de intentos: Total de veces que repetimos el experimento para obtener un promedio significativo.
Secuencia de tiros: Lista que contiene los resultados de cada lanzamiento de dado por intento.
¬øC√≥mo calculamos las probabilidades?
El c√°lculo de probabilidades sigue estos pasos esenciales:

Inicializaci√≥n: Almacenamos el n√∫mero de veces que ocurre cierto evento (como obtener un '1' al lanzar el dado) en una variable.
Iteraci√≥n: Ejecutamos el experimento varias veces para cubrir un rango amplio de posibilidades y obtener resultados confiables.
Comparaci√≥n: Comparamos cu√°ntas veces obtuvo el resultado deseado respecto al n√∫mero total de intentos.
C√°lculo: Dividimos el n√∫mero de √©xitos por el total de intentos para calcular la probabilidad.
```PYTHON


```

## CLASE 12: Inferencia Estad√≠stica: Conceptos y Aplicaciones Pr√°cticas

¬øQu√© es la inferencia estad√≠stica?
La inferencia estad√≠stica es una herramienta poderosa que nos permite derivar propiedades de una poblaci√≥n a partir de una muestra. Imagine tener que averiguar la altura promedio de los hombres adultos en Am√©rica Latina pero sin acceso a toda la poblaci√≥n. Realizar un censo total no solo es inviable en la pr√°ctica, sino tambi√©n innecesario cuando podemos usar t√©cnicas de inferencia estad√≠stica. Al extraer una muestra representativa y aleatoria, podemos hacer inferencias v√°lidas sobre la poblaci√≥n general. Pero, ¬øc√≥mo se logra esto?

¬øC√≥mo se obtiene una muestra representativa?
Para que la inferencia estad√≠stica funcione, la muestra debe ser aleatoria y representativa. Si existe sesgo en la selecci√≥n de la muestra, las inferencias estar√°n sesgadas tambi√©n. Por ello, es crucial que la muestra abarque una diversidad que refleje a la poblaci√≥n. La inferencia estad√≠stica se fundamenta en que a medida que obtenemos m√°s muestras, la probabilidad de que los resultados se acerquen a la realidad aumenta.

¬øQu√© es la Ley de los Grandes N√∫meros?
La Ley de los Grandes N√∫meros es un concepto clave en estad√≠stica que refuerza la validez de las inferencias estad√≠sticas. Este teorema establece que, tras repetir experimentos independientes con la misma probabilidad de un resultado, la diferencia entre el valor observado y el valor esperado se aproximar√° a cero conforme aumenta el n√∫mero de pruebas. En otras palabras, mientras m√°s pruebas realicemos, m√°s cercanas ser√°n nuestras conclusiones a la realidad.

¬øC√≥mo se aplica este concepto en computaci√≥n?
En un contexto computacional, al enfrentar grandes datos, dividir el problema en muestras m√°s peque√±as y manejables es pr√°ctico y efectivo. Este enfoque no solo ahorra recursos de c√≥mputo, sino que tambi√©n limita la necesidad de procesar conjuntos de datos completos cada vez.

¬øQu√© es la falacia del apostador?
La falacia del apostador es un error com√∫n que surge al suponer que despu√©s de una serie de eventos extremos, deber√≠an ocurrir eventos opuestos para equilibrar el promedio. Sin embargo, esto es incorrecto ya que cada evento es independiente. Un ejemplo cl√°sico es la historia de la ruleta de Montecarlo, donde los jugadores, err√≥neamente, apostaron por el negro despu√©s de 32 rojos consecutivos, creyendo que deb√≠a equilibrarse.

¬øQu√© es la regresi√≥n a la media?
La regresi√≥n a la media, a diferencia de la falacia del apostador, es un fen√≥meno estad√≠stico v√°lido. Estipula que tras un evento aleatorio extremo, el pr√≥ximo evento tender√° a acercarse m√°s a la media. Esto no implica que los eventos deben equilibrar, sino que es menos probable que contin√∫e la desviaci√≥n extrema.

Aplicaciones pr√°cticas de la inferencia estad√≠stica
La inferencia estad√≠stica se puede aplicar en m√∫ltiples contextos, desde computaci√≥n y ciencia de datos hasta ciencias sociales. En situaciones donde no es posible manejar toda la poblaci√≥n, el uso estrat√©gico de muestras permite generar predicciones y conclusiones precisas.

En las pr√≥ximas lecciones, se profundizar√° en conceptos que hacen de la inferencia estad√≠stica una herramienta poderosa y c√≥mo aplicar estos conceptos para obtener intervalos de confianza y calcular medias de poblaciones. Este conocimiento te proporcionar√° una base s√≥lida para trabajar con datos de manera eficiente y precisa.

```PYTHON


```


## CLASE 13:  C√°lculo de la Media Aritm√©tica en Python paso a paso

¬øC√≥mo se calcula la media en estad√≠stica?
Calcular la media es un paso fundamental en la inferencia estad√≠stica, ya que es una medida de tendencia central que ayuda a comprender d√≥nde se encuentra la mayor√≠a de los valores en una muestra o poblaci√≥n. La media de la poblaci√≥n se conoce com√∫nmente como $\mu$ (muy), mientras que la media de la muestra se representa con $\bar{x}$ (x barra).

Para calcular la media:

Suma todos los valores en un conjunto.
Divide esa suma por el n√∫mero total de valores.
Por ejemplo, si tienes tres calificaciones: 10, 9 y 8, la suma es 27. Dividimos esta suma por 3 (el n√∫mero total de calificaciones), lo que resulta en una media de 9. En t√©rminos matem√°ticos, la f√≥rmula se representa como:

[ \bar{x} = \frac{\sum x_i}{n} ]

Donde:

(\sum x_i) es la suma de todos los valores.
(n) es el n√∫mero total de valores.
¬øC√≥mo implementar la media en Python?
La implementaci√≥n del c√°lculo de la media en Python es sencilla y se puede realizar con pocas l√≠neas de c√≥digo. Aqu√≠ te mostramos c√≥mo se puede hacer:

def calcular_media(X):
    return sum(X) / len(X)
¬øC√≥mo utilizar esta funci√≥n?
Para comprender mejor c√≥mo usar esta funci√≥n, veamos un ejemplo en el que se utiliza una lista de valores generada aleatoriamente.

import random

if __name__ == "__main__":
    # Generamos una lista aleatoria de 20 n√∫meros entre 1 y 20
    X = [random.randint(1, 20) for _ in range(20)]
    
    # Calculamos la media
    media = calcular_media(X)
    
    # Mostramos la lista y su media
    print("Lista:", X)
    print("Media:", media)
Al ejecutar este fragmento de c√≥digo, obtendr√°s una lista aleatoria de n√∫meros junto con su media. Cada ejecuci√≥n puede generar diferentes resultados debido al uso de n√∫meros aleatorios.

¬øQu√© ventajas ofrece comprender el c√°lculo de la media?
Conocer c√≥mo calcular la media con funciones en Python no solo es una habilidad crucial para la programaci√≥n y an√°lisis de datos, sino que tambi√©n te proporciona las herramientas para comprender y aplicar conocimientos matem√°ticos directamente en el c√≥digo. Este enfoque te ayudar√° a:

Mejorar la habilidad anal√≠tica al realizar an√°lisis de datos m√°s comprensivos.
Facilitar la ejecuci√≥n de t√©cnicas estad√≠sticas que requieren c√°lculos de tendencia central.
Aplicar matem√°tica en programaci√≥n de manera efectiva, superando el miedo a la notaci√≥n matem√°tica y aprendiendo a usarla de forma pr√°ctica.


```PYTHON


```


## CLASE 14: Media, Varianza y Desviaci√≥n Est√°ndar en Estad√≠stica

¬øC√≥mo calcular la varianza y la desviaci√≥n est√°ndar?
El c√°lculo de la varianza y la desviaci√≥n est√°ndar es fundamental para entender la dispersi√≥n de los datos en un conjunto. Estos son dos elementos cruciales en la estad√≠stica inferencial que nos permiten obtener una imagen m√°s clara sobre c√≥mo se distribuyen nuestros datos respecto a la media.

¬øQu√© es la varianza y c√≥mo se calcula?
La varianza nos muestra cu√°n alejados est√°n los datos de la media aritm√©tica, proporcionando una medida de dispersi√≥n en t√©rminos cuadr√°ticos. Calcular la varianza es sencillo, siguiendo estos pasos:

Calcular la media: Primero, obt√©n el promedio de todos los valores.
Restar la media de cada valor: Posteriormente, resta la media de cada uno de los valores del conjunto de datos.
Elevar las diferencias al cuadrado: Eleva al cuadrado las diferencias obtenidas, eliminando as√≠ los valores negativos.
Sumar todos los valores al cuadrado: Calcula la suma de todos los valores al cuadrado obtenidos.
Dividir entre el n√∫mero total de elementos: Este resultado se divide por el n√∫mero total de elementos en el conjunto de datos.
Aqu√≠ est√° el c√≥digo que ilustra c√≥mo calcular la varianza en Python:

def varianza(x):
    media = calcular_media(x)
    acumulador = 0
    for xi in x:
        acumulador += (xi - media) ** 2
    return acumulador / len(x)
¬øQu√© es la desviaci√≥n est√°ndar?
La desviaci√≥n est√°ndar es la ra√≠z cuadrada de la varianza. Nos permite expresar la variabilidad de los datos en las mismas unidades que la media, facilitando as√≠ su interpretaci√≥n. La desviaci√≥n est√°ndar indica, de una manera m√°s clara, cu√°n dispersos est√°n los datos alrededor de la media.

C√≥digo para calcular la desviaci√≥n est√°ndar:

import math

def desviacion_estandar(x):
    return math.sqrt(varianza(x))
¬øPor qu√© es importante entender la media, la varianza y la desviaci√≥n est√°ndar?
Al estudiar un conjunto de datos, es esencial no solo conocer el promedio, sino tambi√©n comprender c√≥mo los datos se dispersan alrededor de este. Por ejemplo, tener una media no nos dice cu√°ndo los datos se encuentran muy alejados unos de otros o est√°n muy agrupados. La desviaci√≥n est√°ndar y la varianza brindan una visi√≥n m√°s completa al respecto.

Ejemplo pr√°ctico:
Datos: Un conjunto de alturas con una media de aproximadamente 1.80 metros puede tener una desviaci√≥n est√°ndar significativamente diferente dependiendo de la dispersi√≥n de los valores.

Alta varianza/desviaci√≥n est√°ndar: Significa que las alturas var√≠an de manera considerable con respecto a la media.
Baja varianza/desviaci√≥n est√°ndar: Indica que las alturas est√°n cercanas al valor promedio.
F√≥rmulas clave y su implementaci√≥n en c√≥digo
Como se ha mostrado, calcular la media es el primer paso:

def calcular_media(x):
    return sum(x) / len(x)
Utilizando estas implementaciones, podemos entender mejor la variabilidad de los datos:

datos = [9, 10, 11]
media = calcular_media(datos)
var = varianza(datos)
desvest = desviacion_estandar(datos)

print(f"Media: {media}, Varianza: {var}, Desviaci√≥n Est√°ndar: {desvest}")
Este enfoque permite evaluar estad√≠sticamente un conjunto de datos, lo que es esencial para realizar inferencias estad√≠sticas v√°lidas. Asimismo, entender la varianza y la desviaci√≥n est√°ndar permite realizar muestreos e inferencias m√°s precisas en diferentes contextos de an√°lisis de datos. No olvides que cada consulta o duda sobre este tema puede ser discutida y resuelta en los sistemas de comentarios o foros especializados en estad√≠stica. ¬°Sigue explorando el mundo de la estad√≠stica inferencial!

```PYTHON


```

## CLASE 15: 

```PYTHON


```

## CLASE 16: 


```PYTHON


```
## CLASE 17: 
```PYTHON


```


## CLASE 18: 

```PYTHON


```

## CLASE 19: 

```PYTHON


```

## CLASE 20: 
```PYTHON


```