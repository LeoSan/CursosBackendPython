# Curso de Estad√≠stica Computacional con PythonüöÄ

> Domina la estad√≠stica computacional usando Python para analizar datos, realizar simulaciones y calcular probabilidades. Aprende a aplicar t√©cnicas de inferencia estad√≠stica y a desarrollar simulaciones de Monte Carlo.

| Detalle | Informaci√≥n |
| :--- | :--- |
| **Publicado el** | 24 FEBRERO 2025 |
| **Profesor** | DAVID AROESTI  |
| **Fecha de Inicio** | 11/12/2025  |
| **Fecha de Fin** | 31/12/2025  |
| **Enlace** | https://platzi.com/cursos/programacion-estocastica/ |


---
<div align="center">
  <img src="image-2.png" alt="Global Certificate" width="50%" />
</div>


| Curso | Certificado |
| :--- | :---: |
| Curso de Estad√≠stica Computacional con Python | [Ver PDF](https://github.com/LeoSan/CursosBackendPython/blob/main/02_DesarrolloBackendPythonDjango_2025_Avanzado\05_CursoEstadisticaComputacionalPython\2025_CursoEstadisticaComputacionalPython_PLATZI.pdf) |

--- 

## CLASE 01: INTRODUCCI√ìN 

**Objetivos**
‚óè Aprender cu√°ndo utilizar Programaci√≥n
Din√°mica y sus beneficios
‚óè Entender la diferencia entre programas
deterministas y estoc√°sticos
‚óè Aprender a utilizar Programaci√≥n Estoc√°stica
‚óè Aprender a crear simulaciones computacionales
v√°lidas

## CLASE 02: Programaci√≥n Din√°mica: Optimizaci√≥n de Problemas con Memorizaci√≥n

> [El nombre] Programaci√≥n Din√°mica se escogi√≥ para esconder a patrocinadores gubernamentales el hecho que en realidad estaba haciendo Matem√°ticas. La frase Programaci√≥n Din√°mica es algo que ning√∫n congresista puede oponerse. **Richard Bellman**


**PUNTOS CLAVES**

> Programaci√≥n Din√°mica
‚óè Subestructura √ìptima. Una soluci√≥n global
√≥ptima se puede encontrar al combinar
soluciones √≥ptimas de subproblemas locales.
‚óè Problemas empalmados. Una soluci√≥n √≥ptima
que involucra resolver el mismo problema en
varias ocasiones.


> Memoization
‚óè La Memorizaci√≥n es una t√©cnica para guardar
c√≥mputos previos y evitar realizarlos
nuevamente.
‚óè Normalmente se utiliza un diccionario, donde las
consultas se pueden hacer en O(1).
‚óè Intercambia tiempo por espacio.


**¬øQu√© es la programaci√≥n din√°mica?**

La programaci√≥n din√°mica es un concepto indispensable en el mundo de las ciencias de la computaci√≥n. A pesar de su nombre, el cual no refleja su verdadera esencia, es una t√©cnica poderosa para optimizar ciertos tipos de problemas. La historia de su origen es peculiar: Richard Bellman acu√±√≥ este t√©rmino en la d√©cada de 1950 para garantizar el financiamiento de sus investigaciones matem√°ticas, utilizando un nombre que sonara impresionante pero que, curiosamente, no est√° relacionado con el dinamismo. Sin embargo, su aplicaci√≥n ha demostrado ser fundamental en la inform√°tica.

**¬øC√≥mo funciona la programaci√≥n din√°mica?**

La programaci√≥n din√°mica se centra en problemas con una "subestructura √≥ptima". Esto significa que la soluci√≥n global √≥ptima se puede alcanzar dividiendo el problema en partes m√°s peque√±as, resolviendo cada una de manera √≥ptima antes de combinarlas para obtener la soluci√≥n total. Ejemplos de su aplicaci√≥n incluyen:

- El problema del morral (Knapsack problem): Aqu√≠ se buscan soluciones √≥ptimas en problemas cada vez m√°s peque√±os.

- La secuencia de Fibonacci: La soluci√≥n se genera dividiendo el problema en partes m√°s reducidas y encontrando soluciones para cada segmento menor.

- Las soluciones a estos problemas m√°s peque√±os se combinan para hallar una soluci√≥n a la totalidad del problema.

**¬øQu√© es la memorizaci√≥n en programaci√≥n din√°mica?**

La memorizaci√≥n es crucial para hacer eficiente la programaci√≥n din√°mica. Se utiliza para evitar c√°lculos innecesarios al almacenar resultados de computaciones previas en una estructura de datos, como un diccionario, que nos permite acceder r√°pidamente a estos datos almacenados. He aqu√≠ algunos puntos clave sobre la memorizaci√≥n:

Optimizaci√≥n de tiempo: Al guardar los resultados en la memoria del sistema, se disminuyen significativamente los tiempos de c√≥mputo.

Intercambio de tiempo por espacio: Este concepto es esencial en ciencias de la computaci√≥n, donde al aumentar el uso del espacio de memoria, se reduce el tiempo necesario para la soluci√≥n del problema.

Utilizando la memorizaci√≥n, se logra que los programas no repitan c√°lculos ya realizados, lo que resulta en la ejecuci√≥n de programas mucho m√°s r√°pidos y eficientes.

**¬øCu√°les son las aplicaciones pr√°cticas de la programaci√≥n din√°mica?**
La programaci√≥n din√°mica se aplica a una variedad de problemas, haciendo de su comprensi√≥n algo esencial para cualquier estudiante de inform√°tica. Con ejemplos amplios en algoritmos y optimizaci√≥n, contin√∫a siendo un √°rea f√©rtil para el aprendizaje y la aplicaci√≥n:

- Ordenaci√≥n y b√∫squeda: Se utilizan t√©cnicas para estructurar datos ordenadamente y b√∫squedas eficientes.

- Resoluci√≥n de problemas matem√°ticos complejos: Desde la secuencia de Fibonacci hasta problemas de combinatoria, la programaci√≥n din√°mica ofrece formas eficientes de llegar a soluciones.

- Optimizaci√≥n de recursos: Eficiente en tareas de asignaci√≥n de recursos y planificaci√≥n.

- Aprovechar las t√©cnicas de programaci√≥n din√°mica no solo refuerza la comprensi√≥n te√≥rica, sino que potencia la capacidad de resolver problemas complejos de manera sistem√°tica y optimizada.

**En conclusi√≥n, la programaci√≥n din√°mica y la memorizaci√≥n son conceptos que, aunque quiz√°s intrincados en su origen, se revelan como herramientas esenciales en la caja de herramientas de cualquier ingeniero en inform√°tica. Su dominio abre puertas a la optimizaci√≥n de programas y algoritmos, culminando en soluciones eficientes e innovadoras. Contin√∫a explorando estos conceptos para mejorar tu comprensi√≥n del fascinante mundo de las ciencias de la computaci√≥n.**


![alt text](image.png)

## CLASE 03:  Optimizaci√≥n de Algoritmos con Programaci√≥n Din√°mica en Python


**¬øQu√© es la Programaci√≥n Din√°mica?**
La programaci√≥n din√°mica es una metodolog√≠a de optimizaci√≥n que ahorra tiempo al intercambiar espacio. Utiliza la memorizaci√≥n para evitar c√°lculos repetidos al guardar los resultados de subproblemas que se pueden reutilizar. Esto es esencial en problemas donde hay muchas subestructuras comunes, como es el caso de la secuencia de Fibonacci.

**¬øC√≥mo se implementa la secuencia de Fibonacci de forma recursiva?**
A pesar de ser sencilla de implementar, la soluci√≥n recursiva a la secuencia de Fibonacci es ineficiente debido al c√°lculo repetido de los mismos subproblemas. El algoritmo recursivo es el siguiente:

```PYTHON

import sys
sys.setrecursionlimit(10002)

def fibonacci_dinamico(n, memo = {}):
    if n == 0 or n == 1:
        return 1
    if n in memo:
        return memo[n]
    memo[n] = fibonacci_dinamico(n-1, memo) + fibonacci_dinamico(n-2, memo)
    return memo[n]

if __name__ == '__main__':
    n = int(input("Escoge un n√∫mero: "))
    print(f"Fibonacci de {n} es {fibonacci_dinamico(n)}")    

```

> Recuerda programaci√≥n algoritmica depende de la complegidad algoritmica ya que hay que saber a nivel de base que tipo de complejidad tiene el algoritmo.


**Dejo base de la complejidad algoritmica Complejidad Algor√≠tmica (Big O Notation)**
![alt text](image-1.png)

"""
üü¢ Zona Verde: P (Tiempo Polin√≥mico - "Eficiente")
Estos son los algoritmos que las computadoras pueden resolver en un tiempo razonable, incluso con muchos datos.

- $O(1)$ - Constante: El mejor de todos. No importa si tienes 10 datos o 1 mill√≥n, toma el mismo tiempo.
Ejemplo: Acceder a un valor en un diccionario de Python o un array por su √≠ndice.

- $O(\log n)$ - Logar√≠tmica: Muy r√°pido. El tiempo crece muy lentamente comparado con los datos.
Ejemplo: B√∫squeda binaria (buscar una palabra en un diccionario f√≠sico abriendo por la mitad).

- $O(n)$ - Lineal: El tiempo crece proporcionalmente a los datos. Si duplicas los datos, duplicas el tiempo.
Ejemplo: Recorrer una lista con un bucle for simple.

- $O(n \log n)$: Un poco m√°s lento que lineal, pero muy eficiente. Es el est√°ndar para ordenar cosas.
Ejemplo: Los algoritmos de ordenamiento eficientes como Merge Sort o Quick Sort (lo que usa .sort() en Python).

- $O(n^2)$ - Cuadr√°tica: El tiempo crece al cuadrado. Com√∫n en algoritmos "ingenuos".
Ejemplo: Un bucle for dentro de otro (bucles anidados). Com√∫n en ordenamiento burbuja.

- $O(n^3)$ y $O(n^k)$: C√∫bica o Polin√≥mica general. Bucles triples, cu√°druples, etc. Sigue siendo "resoluble" (est√° en P), pero se vuelve lento r√°pido.


üî¥ Zona Roja: NP (No Polin√≥mico* / Intratable)
- Nota t√©cnica: Aunque la imagen dice "NP", en este contexto visual se refiere a algoritmos que "No son Polin√≥micos" o que son Exponenciales/Factoriales. 
- Estos algoritmos son tan lentos que se vuelven in√∫tiles si $n$ crece un poco (por ejemplo, si $n=100$, el programa podr√≠a tardar siglos).

- $O(2^n)$ - Exponencial: Por cada dato nuevo, el tiempo se duplica. Esto explota rapid√≠simo.
Ejemplo: Fibonacci Recursivo sin memoria (el que viste en tu README antes de optimizar). Calcular Fibonacci de 50 as√≠ podr√≠a tardar a√±os.

- $O(n!)$ - Factorial: La peor pesadilla. Crece monstruosamente r√°pido.
Ejemplo: El problema del viajero (probar todas las rutas posibles entre ciudades). Si tienes 20 ciudades, es casi imposible de calcular a fuerza bruta.

""" 
## CLASE 04: Simulaciones con Caminos Aleatorios en Programaci√≥n

**¬øC√≥mo explicaron Einstein y el movimiento browniano esta teor√≠a?**

Uno de los ejemplos m√°s sorprendentes y fundamentales del uso de aleatoriedad es el movimiento browniano. En el siglo XIX, la mejora en los microscopios permiti√≥ observar comportamientos inesperados en part√≠culas microsc√≥picas que no pod√≠an ser explicados con el conocimiento de la √©poca. Fue Albert Einstein el que explic√≥ este fen√≥meno siendo un pionero en el uso de la aleatoriedad para entender c√≥mo las mol√©culas de agua, al moverse aleatoriamente, impactan part√≠culas de polen, generando lo que se conoce como movimiento browniano. Este descubrimiento le vali√≥ el Premio Nobel, no por su teor√≠a de la relatividad, sino por este entendimiento profundo del comportamiento aleatorio a nivel molecular.

**¬øQu√© aplicaciones tienen los caminos aleatorios en las simulaciones?**
Los caminos aleatorios son la clave para crear simulaciones avanzadas y precisas en m√∫ltiples campos:

Simulaci√≥n de part√≠culas: Las simulaciones como la del humo, utilizan caminos aleatorios para modelar el comportamiento de millones de part√≠culas. Mediante la definici√≥n de un comportamiento general, las part√≠culas se mueven de manera aleatoria, reproduciendo el movimiento ca√≥tico del humo.

Uni√≥n de galaxias: A nivel macro, estas simulaciones ayudan a entender fen√≥menos astron√≥micos. Por ejemplo, la probable fusi√≥n de la galaxia V√≠a L√°ctea con Andr√≥meda es modelada usando caminos aleatorios, permitiendo prever el comportamiento de las estrellas y la gravedad involucradas.

Mercados financieros: En el √°mbito econ√≥mico, se utilizan para simular el comportamiento del mercado de valores, ayudando a predecir c√≥mo las acciones pueden subir o bajar en el tiempo.

**¬øQu√© relaci√≥n tienen con el arte y la tecnolog√≠a?**
La aleatoriedad no se limita al √°mbito cient√≠fico, tambi√©n se extiende a la creaci√≥n art√≠stica:

Escultura de nube cu√°ntica: Un ejemplo fascinante es el Quantum Cloud en Londres. Esta atracci√≥n tur√≠stica utiliza caminos aleatorios computacionales para posicionar los elementos de la escultura, creando as√≠ una estructura singular que desaf√≠a las nociones tradicionales del arte.

```PYTHON


```
![alt text](image-3.png)

## CLASE 05: Camino Aleatorio en Programaci√≥n Orientada a Objetos

**¬øQu√© es la programaci√≥n din√°mica y estoc√°stica?**

La programaci√≥n din√°mica y estoc√°stica es una t√©cnica que se utiliza en el dise√±o de algoritmos para resolver problemas de optimizaci√≥n que se caracterizan por la incertidumbre y la necesidad de tomar decisiones secuenciales. Esta t√©cnica es fundamental en la resoluci√≥n de problemas en diversos campos como la ingenier√≠a, la econom√≠a o las ciencias de la computaci√≥n.

En este contexto, la profesora introduce un concepto interesante: el camino de borrachos. Descubramos c√≥mo este concepto se materializa en un algoritmo de programaci√≥n orientada a objetos.

**¬øC√≥mo se implementa el camino de borrachos?**
El algoritmo del camino de borrachos se deriva de un problema que simula el movimiento aleatorio de un borracho que camina en un campo. Para entender c√≥mo se desarrolla este concepto en programaci√≥n, dividimos el problema en tres clases fundamentales:

Borracho: Un objeto que representa a una persona que se mueve de manera aleatoria.
Campo: Un objeto que define el entorno o mapa en el cual el borracho se mueve.
Coordenada: Un concepto abstracto que sirve para definir la posici√≥n dentro del campo.

**¬øC√≥mo se representa a trav√©s de programaci√≥n orientada a objetos?**
La programaci√≥n orientada a objetos permite modelar el mundo real creando clases y objetos. En el caso del camino de borrachos, las clases mencionadas se configuran de la siguiente manera:

Borracho: Puede imaginarse como un individuo que se mueve dentro de las coordenadas de un campo. Adem√°s, se pueden extender sus caracter√≠sticas para definir comportamientos espec√≠ficos, como un "borracho tradicional" que se mueve aleatoriamente a uno de los lados cardinales.

Campo: Funciona como un mapa y contiene las disposiciones de las coordenadas, permitiendo que el borracho se desplace dentro de √©l.

Coordenada: Es como un marcador que se√±ala la posici√≥n actual del borracho dentro del campo, similar a un pin en Google Maps.

**¬øC√≥mo se implementa el movimiento del borracho?**
El borracho se mueve aleatoriamente dentro del campo a trav√©s de movimientos en los ejes X e Y. Estos movimientos pueden ser:

Hacia la izquierda: decremento en el eje X.
Hacia la derecha: incremento en el eje X.
Hacia arriba: incremento en el eje Y.
Hacia abajo: decremento en el eje Y.
Aqu√≠ les presento un fragmento del c√≥digo en Python:

class Borracho:
    def __init__(self):
        pass

    def mover(self):
        return random.choice([(1,0), (0,1), (-1,0), (0,-1)])

class Campo:
    def __init__(self):
        pass
¬øC√≥mo se integran estas clases en la funci√≥n principal?
Para concretar el comportamiento del borracho y sus desplazamientos, es necesario definir una funci√≥n principal o main, un punto de entrada com√∫n en la mayor√≠a de los lenguajes de programaci√≥n:

if __name__ == '__main__':
    # Implementaci√≥n del movimiento del borracho
    # C√≥digo para crear instancias de las clases e interactuar con ellas
El main se encarga de gestionar el flujo del programa: crear objetos, iniciar movimientos y registrar resultados. Se pueden implementar simulaciones para ver c√≥mo var√≠a la posici√≥n del borracho tras un n√∫mero determinado de pasos.

¬øC√≥mo se eval√∫an los resultados de las simulaciones?
En programaci√≥n estoc√°stica, ejecutar una simulaci√≥n una sola vez no proporciona suficiente informaci√≥n debido a su componente aleatorio. Por ello, es necesario realizar m√∫ltiples simulaciones para obtener resultados promedio m√°s fiables.

Simulaciones M√∫ltiples: Es importante ejecutar varias simulaciones (por ejemplo, 100) para cada n√∫mero de pasos definido, obteniendo as√≠ la media de las distancias recorridas.

Distancias M√°xima y M√≠nima: Evaluar la distancia m√°xima y m√≠nima alcanzada por el borracho en las distintas simulaciones proporciona insights sobre el comportamiento y alcance de los movimientos.


```PYTHON
import random

class Borracho:

    def __init__(self):
        self.posicion = [0,0]


    def camino_borrachos(self, pasos=0):
        direccion = random.choice(["derecha","izquierda","arriba","abajo"])
        for i in range(pasos):
            direccion = random.choice(["derecha", "izquierda", "arriba", "abajo"])
            if direccion == "izquierda":
                self.posicion[0] -= 1
            elif direccion == "derecha":
                self.posicion[0] += 1
            elif direccion == "arriba":
                self.posicion[1] += 1
            elif direccion == "abajo":
                self.posicion[1] -= 1
            else:
                return None
        return self.posicion

if __name__ == "__main__":
    borrachin = Borracho()
    direccion_final = borrachin.camino_borrachos(pasos=500)
    print(direccion_final)
    distancia_final = (direccion_final[0]**2+direccion_final[1]**2)**0.5
    print("La distancia final es: ",distancia_final)

```

![alt text](image-2.png)

## CLASE 06: 
```PYTHON


```


## CLASE 07: 

```PYTHON


```

## CLASE 08: 

```PYTHON


```

## CLASE 09: 
```PYTHON


```


## CLASE 10: 

```PYTHON


```

## CLASE 11: 

```PYTHON


```

## CLASE 12: 



```PYTHON


```


## CLASE 13: 
```PYTHON


```


## CLASE 14: 

```PYTHON


```

## CLASE 15: 

```PYTHON


```

## CLASE 16: 


```PYTHON


```
## CLASE 17: 
```PYTHON


```


## CLASE 18: 

```PYTHON


```

## CLASE 19: 

```PYTHON


```

## CLASE 20: 
```PYTHON


```